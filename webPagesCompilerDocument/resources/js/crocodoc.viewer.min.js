/*! Crocodoc Viewer - v0.10.11 | (c) 2016 Box */
!function(a){/*global jQuery*/
/*jshint unused:false, undef:false*/
"use strict";a.Crocodoc=function(a){
// nodejs / browserify - export a function that accepts a jquery impl
return"object"!=typeof exports?a(jQuery):void(module.exports=a)}(function(b){/**
 * Creates a global method for loading svg text into the proxy svg object
 * @NOTE: this function should never be called directly in this context;
 * it's converted to a string and encoded into the proxy svg data:url
 * @returns {void}
 * @private
 */
function c(){a.loadSVG=function(b){var c=new a.DOMParser,d=c.parseFromString(b,"image/svg+xml"),e=document.importNode(d.documentElement,!0);
// make sure the svg width/height are explicity set to 100%
e.setAttribute("width","100%"),e.setAttribute("height","100%"),document.body?document.body.appendChild(e):document.documentElement.appendChild(e)}}var d="crocodoc-",e="data-svg-version",f=d+"viewer",g=d+"doc",h=d+"viewport",i=d+"viewer-logo",j=d+"draggable",k=d+"dragging",l=d+"text-selected",m=d+"text-disabled",n=d+"links-disabled",o=d+"mobile",p=d+"ielt9",q=d+"supports-svg",r=d+"window-as-viewport",s=d+"layout-",t=d+"current-page",u=d+"preceding-page",v=d+"page",w=v+"-inner",x=v+"-content",y=v+"-svg",z=v+"-text",A=v+"-link",B=v+"-links",C=v+"-autoscale",D=v+"-loading",E=v+"-error",F=v+"-visible",C=v+"-autoscale",G=v+"-prev",H=v+"-next",I=v+"-before",J=v+"-after",K=v+"-before-buffer",L=v+"-after-buffer",M=[H,J,G,I,K,L].join(" "),N='<div tabindex="-1" class="'+h+'"><div class="'+g+'"></div></div><div class="'+i+'"></div>',O='<div class="'+v+" "+D+'" style="width:{{w}}px; height:{{h}}px;" data-width="{{w}}" data-height="{{h}}"><div class="'+w+'"><div class="'+x+'"><div class="'+y+'"></div><div class="'+C+'"><div class="'+z+'"></div><div class="'+B+'"></div></div></div></div></div>',P=1024,Q="fitwidth",R="fitheight",S="auto",T="in",U="out",V="previous",W="next",X="vertical",Y="vertical-single-column",Z="horizontal",$="presentation",_="presentation-two-page",aa="text",ba="converting",ca="not loaded",da="loading",ea="loaded",fa="error",ga="padding-",ha=ga+"top",ia=ga+"right",ja=ga+"left",ka=ga+"bottom",
// threshold for removing similar zoom levels (closer to 1 is more similar)
la=.95,
// threshold for removing similar zoom presets (e.g., auto, fit-width, etc)
ma=.99,na=100,//ms between initiating page loads
oa=32,pa=8,
// the delay in ms to wait before triggering preloading after `ready`
qa=1e3,ra="image/svg+xml",sa="<style>html,body{width:100%;height:100%;margin:0;overflow:hidden;}</style>",ta='<svg version="1.1" xmlns="http://www.w3.org/2000/svg"><script><![CDATA[('+c+")()]]></script></svg>",
// Embed the svg in an iframe (initialized to about:blank), and inject
// the SVG directly to the iframe window using document.write()
// @NOTE: this breaks images in Safari because [?]
ua=1,
// Embed the svg with a data-url
// @NOTE: ff allows direct script access to objects embedded with a data url,
//        and this method prevents a throbbing spinner because document.write
//        causes a spinner in ff
// @NOTE: NOT CURRENTLY USED - this breaks images in firefox because:
//        https://bugzilla.mozilla.org/show_bug.cgi?id=922433
va=2,
// Embed the svg directly in html via inline svg.
// @NOTE: NOT CURRENTLY USED -  seems to be slow everywhere, but I'm keeping
//        this here because it's very little extra code, and inline SVG might
//        be better some day?
wa=3,
// Embed the svg directly with an object tag; don't replace linked resources
// @NOTE: NOT CURRENTLY USED - this is only here for testing purposes, because
//        it works in every browser; it doesn't support query string params
//        and causes a spinner
xa=4,
// Embed the svg directly with an img tag; don't replace linked resources
// @NOTE: NOT CURRENTLY USED - this is only here for testing purposes
ya=5,
// Embed a proxy svg script as an object tag via data:url, which exposes a
// loadSVG method on its contentWindow, then call the loadSVG method directly
// with the svg text as the argument
// @NOTE: only works in firefox because of its security policy on data:uri
za=6,
// Embed in a way similar to the EMBED_STRATEGY_DATA_URL_PROXY, but in this
// method we use an iframe initialized to about:blank and embed the proxy
// script before calling loadSVG on the iframe's contentWindow
// @NOTE: this is a workaround for the image issue with EMBED_STRATEGY_IFRAME_INNERHTML
//        in safari; it also works in firefox
Aa=7,
// Embed in an img tag via data:url, downloading stylesheet separately, and
// injecting it into the data:url of SVG text before embedding
// @NOTE: this method seems to be more performant on IE
Ba=8;/*jshint unused:false*/
if("undefined"==typeof b)throw new Error("jQuery is required");/**
 * The one global object for Crocodoc JavaScript.
 * @namespace
 */
var Ca=function(){/**
     * Find circular dependencies in component mixins
     * @param   {string} componentName   The component name that is being added
     * @param   {Array} dependencies  Array of component mixin dependencies
     * @param   {void} path           String used to keep track of depencency graph
     * @returns {void}
     */
function a(c,d,e){var f;for(e=e||c,f=0;f<d.length;++f){if(c===d[f])throw new Error("Circular dependency detected: "+e+"->"+d[f]);b[d[f]]&&a(c,b[d[f]].mixins,e+"->"+d[f])}}var b={},c={};return{
// Zoom, scroll, page status, layout constants
ZOOM_FIT_WIDTH:Q,ZOOM_FIT_HEIGHT:R,ZOOM_AUTO:S,ZOOM_IN:T,ZOOM_OUT:U,SCROLL_PREVIOUS:V,SCROLL_NEXT:W,LAYOUT_VERTICAL:X,LAYOUT_VERTICAL_SINGLE_COLUMN:Y,LAYOUT_HORIZONTAL:Z,LAYOUT_PRESENTATION:$,LAYOUT_PRESENTATION_TWO_PAGE:_,LAYOUT_TEXT:aa,
// The number of times to retry loading an asset before giving up
ASSET_REQUEST_RETRIES:1,
// templates exposed to allow more customization
viewerTemplate:N,pageTemplate:O,
// exposed for testing purposes only
// should not be accessed directly otherwise
components:b,utilities:c,/**
         * Create and return a viewer instance initialized with the given parameters
         * @param {string|Element|jQuery} el The element to bind the viewer to
         * @param {Object} config            The viewer configuration parameters
         * @returns {Object}                 The viewer instance
         */
createViewer:function(a,b){return new Ca.Viewer(a,b)},/**
         * Get a viewer instance by id
         * @param {number} id   The id
         * @returns {Object}    The viewer instance
         */
getViewer:function(a){return Ca.Viewer.get(a)},/**
         * Register a new component
         * @param  {string} name      The (unique) name of the component
         * @param  {Array} mixins     Array of component names to instantiate and pass as mixinable objects to the creator method
         * @param  {Function} creator Factory function used to create an instance of the component
         * @returns {void}
         */
addComponent:function(c,d,e){d instanceof Function&&(e=d,d=[]),
// make sure this component won't cause a circular mixin dependency
a(c,d),b[c]={mixins:d,creator:e}},/**
         * Create and return an instance of the named component
         * @param  {string} name The name of the component to create
         * @param  {Crocodoc.Scope} scope The scope object to create the component on
         * @returns {?Object}     The component instance or null if the component doesn't exist
         */
createComponent:function(a,c){var d=b[a];if(d){for(var e=[],f=0;f<d.mixins.length;++f)e.push(this.createComponent(d.mixins[f],c));return e.unshift(c),d.creator.apply(d.creator,e)}return null},/**
         * Register a new Crocodoc plugin
         * @param  {string} name      The (unique) name of the plugin
         * @param  {Function} creator Factory function used to create an instance of the plugin
         * @returns {void}
         */
addPlugin:function(a,b){this.addComponent("plugin-"+a,b)},/**
         * Register a new Crocodoc data provider
         * @param {string} modelName The model name this data provider provides
         * @param {Function} creator Factory function used to create an instance of the data provider.
         */
addDataProvider:function(a,b){this.addComponent("data-provider-"+a,b)},/**
         * Register a new utility
         * @param  {string} name    The (unique) name of the utility
         * @param  {Function} creator Factory function used to create an instance of the utility
         * @returns {void}
         */
addUtility:function(a,b){c[a]={creator:b,instance:null}},/**
         * Retrieve the named utility
         * @param {string} name The name of the utility to retrieve
         * @returns {?Object}    The utility or null if the utility doesn't exist
         */
getUtility:function(a){var b=c[a];return b?(b.instance||(b.instance=b.creator(this)),b.instance):null}}}();/**
 * The Crocodoc.Viewer namespace
 * @namespace
 */
/**
 * Common utility functions used throughout Crocodoc JS
 */
/*global window, document*/
/**
 * URL utility
 */
/**
 * Dragger component definition
 */
/**
 * Base layout component for controlling viewer layout and viewport
 */
/**
 * The horizontal layout
 */
/**
 * Base layout component for controlling viewer layout and viewport
 */
/**
 * The presentation-two-page layout
 */
/**
 *The presentation layout
 */
/**
 * Layout for text-based files
 */
/**
 * The vertical-single-column layout
 */
/**
 * The vertical layout
 */
/*global setTimeout, clearTimeout*/
/**
 * lazy-loader component for controlling when pages should be loaded and unloaded
 */
/**
 * page-img component used to display raster image instead of SVG content for
 * browsers that do not support SVG
 */
/**
 * page-links component definition
 */
/**
 * page-svg component
 */
/**
 * page-text component
 */
/**
 * Page component
 */
/**
 * resizer component definition
 */
/*global setTimeout, clearTimeout */
return function(){/**
     * Scope class used for component scoping (creating, destroying, broadcasting messages)
     * @constructor
     */
Ca.Scope=function(a){/**
         * Broadcast a message to all components in this scope that have registered
         * a listener for the named message type
         * @param  {string} messageName The message name
         * @param  {any} data The message data
         * @returns {void}
         * @private
         */
function c(a,b){var c,d,e,h;for(c=0,d=g.length;d>c;++c)e=g[c],e&&(h=e.messages||[],-1!==f.inArray(a,h)&&f.isFn(e.onmessage)&&e.onmessage.call(e,a,b))}/**
         * Broadcasts any (pageavailable) messages that were queued up
         * before the viewer was ready
         * @returns {void}
         * @private
         */
function d(){for(var a;h.length;)a=h.shift(),c(a.name,a.data);h=null}/**
         * Call the destroy method on a component instance if it exists and the
         * instance has not already been destroyed
         * @param   {Object} instance The component instance
         * @returns {void}
         */
function e(a){f.isFn(a.destroy)&&!a._destroyed&&(a.destroy(),a._destroyed=!0)}
//----------------------------------------------------------------------
// Private
//----------------------------------------------------------------------
var f=Ca.getUtility("common"),g=[],h=[],i={},j=!1;
//----------------------------------------------------------------------
// Public
//----------------------------------------------------------------------
a.dataProviders=a.dataProviders||{},/**
         * Create and return an instance of the named component,
         * and add it to the list of instances in this scope
         * @param  {string} componentName The name of the component to create
         * @returns {?Object}     The component instance or null if the component doesn't exist
         */
this.createComponent=function(a){var b=Ca.createComponent(a,this);return b&&(b.componentName=a,g.push(b)),b},/**
         * Remove and call the destroy method on a component instance
         * @param  {Object} instance The component instance to remove
         * @returns {void}
         */
this.destroyComponent=function(a){var b,c;for(b=0,c=g.length;c>b;++b)if(a===g[b]){e(a),g.splice(b,1);break}},/**
         * Remove and call the destroy method on all instances in this scope
         * @returns {void}
         */
this.destroy=function(){var a,b,c,d=g.slice();for(a=0,b=d.length;b>a;++a)c=d[a],e(c);g=[],i={}},/**
         * Broadcast a message or queue it until the viewer is ready
         * @param   {string} name The name of the message
         * @param   {*} data The message data
         * @returns {void}
         */
this.broadcast=function(a,b){j?c(a,b):h.push({name:a,data:b})},/**
         * Passthrough method to the framework that retrieves utilities.
         * @param {string} name The name of the utility to retrieve
         * @returns {?Object}    An object if the utility is found or null if not
         */
this.getUtility=function(a){return Ca.getUtility(a)},/**
         * Get the config object associated with this scope
         * @returns {Object} The config object
         */
this.getConfig=function(){return a},/**
         * Tell the scope that the viewer is ready and broadcast queued messages
         * @returns {void}
         */
this.ready=function(){j||(j=!0,d())},/**
         * Get a model object from a data provider. If the objectType is listed
         * in config.dataProviders, this will get the value from the data
         * provider that is specified in that map instead.
         * @param {string} objectType The type of object to retrieve ('page-svg', 'page-text', etc)
         * @param {string} objectKey  The key of the object to retrieve
         * @returns {$.Promise}
         */
this.get=function(c,d){var e=a.dataProviders[c]||c,f=this.getDataProvider(e);return f?f.get(c,d):b.Deferred().reject("data-provider not found").promise()},/**
         * Get an instance of a data provider. Ignores config.dataProviders
         * overrides.
         * @param {string} objectType The type of object to retrieve a data provider for ('page-svg', 'page-text', etc)
         * @returns {Object} The data provider
         */
this.getDataProvider=function(a){var b;return i[a]?b=i[a]:(b=this.createComponent("data-provider-"+a),i[a]=b),b}}}(),function(){/**
     * Build an event object for the given type and data
     * @param   {string} type The event type
     * @param   {Object} data The event data
     * @returns {Object}      The event object
     */
function a(a,b){var c=!1;return{type:a,data:b,/**
             * Prevent the default action for this event
             * @returns {void}
             */
preventDefault:function(){c=!0},/**
             * Return true if preventDefault() has been called on this event
             * @returns {Boolean}
             */
isDefaultPrevented:function(){return c}}}/**
     * An object that is capable of generating custom events and also
     * executing handlers for events when they occur.
     * @constructor
     */
Ca.EventTarget=function(){/**
         * Map of events to handlers. The keys in the object are the event names.
         * The values in the object are arrays of event handler functions.
         * @type {Object}
         * @private
         */
this._handlers={}},Ca.EventTarget.prototype={
// restore constructor
constructor:Ca.EventTarget,/**
         * Adds a new event handler for a particular type of event.
         * @param {string} type The name of the event to listen for.
         * @param {Function} handler The function to call when the event occurs.
         * @returns {void}
         */
on:function(a,b){"undefined"==typeof this._handlers[a]&&(this._handlers[a]=[]),this._handlers[a].push(b)},/**
         * Fires an event with the given name and data.
         * @param {string} type The type of event to fire.
         * @param {Object} data An object with properties that should end up on
         *      the event object for the given event.
         * @returns {Object} The event object
         */
fire:function(b,c){var d,e,f,g=a(b,c);if(d=this._handlers[g.type],d instanceof Array)for(d=d.concat(),e=0,f=d.length;f>e;e++)d[e]&&d[e].call(this,g);if(d=this._handlers.all,d instanceof Array)for(d=d.concat(),e=0,f=d.length;f>e;e++)d[e]&&d[e].call(this,g);return g},/**
         * Removes an event handler from a given event.
         * If the handler is not provided, remove all handlers of the given type.
         * @param {string} type The name of the event to remove from.
         * @param {Function} handler The function to remove as a handler.
         * @returns {void}
         */
off:function(a,b){var c,d,e=this._handlers[a];if(e instanceof Array){if(!b)return void(e.length=0);for(c=0,d=e.length;d>c;c++)if(e[c]===b||e[c].handler===b){e.splice(c,1);break}}},/**
         * Adds a new event handler that should be removed after it's been triggered once.
         * @param {string} type The name of the event to listen for.
         * @param {Function} handler The function to call when the event occurs.
         * @returns {void}
         */
one:function(a,b){var c=this,d=function(e){c.off(a,d),b.call(c,e)};d.handler=b,this.on(a,d)}}}(),function(){var a=0,c={};/**
     * Crocodoc.Viewer constructor
     * @param {jQuery|string|Element} el The element to wrap
     * @param {Object} options           Configuration options
     * @constructor
     */
Ca.Viewer=function(d,e){function f(){l.init()}
// call the EventTarget constructor to init handlers
Ca.EventTarget.call(this);var g,h=Ca.getUtility("common"),i=b(d),j=h.extend(!0,{},Ca.Viewer.defaults,e),k=new Ca.Scope(j),l=k.createComponent("viewer-base");
//Container exists?
if(0===i.length)throw new Error("Invalid container element");this.id=j.id=++a,j.api=this,j.$el=i,
// register this instance
c[this.id]=this,
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
/**
         * Destroy the viewer instance
         * @returns {void}
         */
this.destroy=function(){
// unregister this instance
delete c[j.id],
// broadcast a destroy message
k.broadcast("destroy"),
// destroy all components and plugins in this scope
k.destroy()},/**
         * Intiate loading of document assets
         * @returns {void}
         */
this.load=function(){l.loadAssets()},/**
         * Set the layout to the given mode, destroying and cleaning up the current
         * layout if there is one
         * @param  {string} mode The layout mode
         * @returns {void}
         */
this.setLayout=function(a){g=null,g=l.setLayout(a)},/**
         * Zoom to the given value
         * @param  {float|string} val Numeric zoom level to zoom to or one of:
         *                            Crocodoc.ZOOM_IN
         *                            Crocodoc.ZOOM_OUT
         *                            Crocodoc.ZOOM_AUTO
         *                            Crocodoc.ZOOM_FIT_WIDTH
         *                            Crocodoc.ZOOM_FIT_HEIGHT
         * @returns {void}
         */
this.zoom=function(a){
// adjust for page scale if passed value is a number
var b=parseFloat(a);g&&(b&&(a=b/(j.pageScale||1)),g.setZoom(a))},/**
         * Scroll to the given page
         * @TODO: rename to scrollToPage when possible (and remove this for non-
         * page-based viewers)
         * @param  {int|string} page Page number or one of:
         *                           Crocodoc.SCROLL_PREVIOUS
         *                           Crocodoc.SCROLL_NEXT
         * @returns {void}
         */
this.scrollTo=function(a){g&&h.isFn(g.scrollTo)&&g.scrollTo(a)},/**
         * Scrolls by the given pixel amount from the current location
         * @param  {int} left Left offset to scroll to
         * @param  {int} top  Top offset to scroll to
         * @returns {void}
         */
this.scrollBy=function(a,b){g&&g.scrollBy(a,b)},/**
         * Focuses the viewport so it can be natively scrolled with the keyboard
         * @returns {void}
         */
this.focus=function(){g&&g.focus()},/**
         * Enable text selection, loading text assets per page if necessary
         * @returns {void}
         */
this.enableTextSelection=function(){i.toggleClass(m,!1),j.enableTextSelection||(j.enableTextSelection=!0,k.broadcast("textenabledchange",{enabled:!0}))},/**
         * Disable text selection, hiding text layer on pages if it's already there
         * and disabling the loading of new text assets
         * @returns {void}
         */
this.disableTextSelection=function(){i.toggleClass(m,!0),j.enableTextSelection&&(j.enableTextSelection=!1,k.broadcast("textenabledchange",{enabled:!1}))},/**
         * Enable links
         * @returns {void}
         */
this.enableLinks=function(){j.enableLinks||(i.removeClass(n),j.enableLinks=!0)},/**
         * Disable links
         * @returns {void}
         */
this.disableLinks=function(){j.enableLinks&&(i.addClass(n),j.enableLinks=!1)},/**
         * Force layout update
         * @returns {void}
         */
this.updateLayout=function(){g&&g.update()},f()},Ca.Viewer.prototype=new Ca.EventTarget,Ca.Viewer.prototype.constructor=Ca.Viewer,/**
     * Get a viewer instance by id
     * @param {number} id   The id
     * @returns {Object}    The viewer instance
     */
Ca.Viewer.get=function(a){return c[a]},
// Global defaults
Ca.Viewer.defaults={
// the url to load the assets from (required)
url:null,
// document viewer layout
layout:X,
// initial zoom level
zoom:S,
// page to start on
page:1,
// enable/disable text layer
enableTextSelection:!0,
// enable/disable links layer
enableLinks:!0,
// enable/disable click-and-drag
enableDragging:!1,
// query string parameters to append to all asset requests
queryParams:null,
// plugin configs
plugins:{},
// whether to use the browser window as the viewport into the document (this
// is useful when the document should take up the entire browser window, e.g.,
// on mobile devices)
useWindowAsViewport:!1,
//--------------------------------------------------------------------------
// The following are undocumented, internal, or experimental options,
// which are very subject to change and likely to be broken.
// --
// USE AT YOUR OWN RISK!
//--------------------------------------------------------------------------
// whether or not the conversion is finished (eg., pages are ready to be loaded)
conversionIsComplete:!0,
// template for loading assets... this should rarely (if ever) change
template:{svg:"page-{{page}}.svg",img:"page-{{page}}.png",html:"text-{{page}}.html",css:"stylesheet.css",json:"info.json"},
// default data-providers
dataProviders:{metadata:"metadata",stylesheet:"stylesheet","page-svg":"page-svg","page-text":"page-text","page-img":"page-img"},
// page to start/end on (pages outside this range will not be shown)
pageStart:null,pageEnd:null,
// whether or not to automatically load page one assets immediately (even
// if conversion is not yet complete)
autoloadFirstPage:!0,
// zoom levels are relative to the viewport size,
// and the dynamic zoom levels (auto, fitwidth, etc) will be added into the mix
zoomLevels:[.25,.5,.75,1,1.25,1.5,2,3]}}(),Ca.addDataProvider("metadata",function(a){/**
     * Process metadata json and return the result
     * @param   {string} json The original JSON text
     * @returns {string}      The processed JSON text
     * @private
     */
function b(a){return d.parseJSON(a)}var c=a.getUtility("ajax"),d=a.getUtility("common"),e=a.getConfig();
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Retrieve the info.json asset from the server
         * @returns {$.Promise} A promise with an additional abort() method that will abort the XHR request.
         */
get:function(){var a=this.getURL(),d=c.fetch(a,Ca.ASSET_REQUEST_RETRIES);
// @NOTE: promise.then() creates a new promise, which does not copy
// custom properties, so we need to create a futher promise and add
// an object with the abort method as the new target
return d.then(b).promise({abort:d.abort})},/**
         * Build and return the URL to the metadata JSON
         * @returns {string}         The URL
         */
getURL:function(){var a=e.template.json;return e.url+a+e.queryString}}}),Ca.addDataProvider("page-img",function(a){var c=a.getUtility("common"),d=a.getConfig();
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Retrieve the page image asset from the server
         * @param {string} objectType The type of data being requested
         * @param {number} pageNum The page number for which to request the page image
         * @returns {$.Promise}    A promise with an additional abort() method that will abort the img request.
         */
get:function(a,c){function d(){f.setAttribute("src",i)}function e(){f&&f.removeAttribute("src")}var f=this.getImage(),g=Ca.ASSET_REQUEST_RETRIES,h=!1,i=this.getURL(c),j=b.Deferred();
// add load and error handlers
// load the image
return f.onload=function(){h=!0,j.resolve(f)},f.onerror=function(){g>0?(g--,e(),d()):(f=null,h=!1,j.reject({error:"image failed to load",resource:i}))},d(),j.promise({abort:function(){h||(e(),j.reject())}})},/**
         * Build and return the URL to the PNG asset for the specified page
         * @param   {number} pageNum The page number
         * @returns {string}         The URL
         */
getURL:function(a){var b=c.template(d.template.img,{page:a});return d.url+b+d.queryString},/**
         * Create and return a new image element (used for testing purporses)
         * @returns {Image}
         */
getImage:function(){return new Image}}}),Ca.addDataProvider("page-svg",function(a){/**
     * Interpolate CSS text into the SVG text
     * @param   {string} text    The SVG text
     * @param   {string} cssText The CSS text
     * @returns {string}         The full SVG text
     */
function b(a,b){
// CSS text
var c="<style>"+b+"</style>";
// If using Firefox with no subpx support, add "text-rendering" CSS.
// @NOTE(plai): We are not adding this to Chrome because Chrome supports "textLength"
// on tspans and because the "text-rendering" property slows Chrome down significantly.
// In Firefox, we're waiting on this bug: https://bugzilla.mozilla.org/show_bug.cgi?id=890692
// @TODO: Use feature detection instead (textLength)
// inline the CSS!
return g.firefox&&!h.isSubpxSupported()&&(c+="<style>text { text-rendering: geometricPrecision; }</style>"),a=a.replace(l,c)}/**
     * Process SVG text and return the embeddable result
     * @param   {string} text The original SVG text
     * @returns {string}      The processed SVG text
     * @private
     */
function c(c){if(!j){var f,g=i.queryString.replace("&","&#38;");
// remove data:urls from the SVG content if the number exceeds MAX_DATA_URLS
// remove all data:url images that are smaller than 5KB
// @TODO: remove this, because we no longer use any external assets in this way
// modify external asset urls for absolute path
return f=e.countInStr(c,'xlink:href="data:image'),f>d&&(c=c.replace(/<image[\s\w-_="]*xlink:href="data:image\/[^"]{0,5120}"[^>]*>/gi,"")),c=c.replace(/href="([^"#:]*)"/g,function(a,b){return'href="'+i.url+b+g+'"'}),a.get("stylesheet").then(function(a){return b(c,a)})}}var d=1e3,e=a.getUtility("common"),f=a.getUtility("ajax"),g=a.getUtility("browser"),h=a.getUtility("subpx"),i=a.getConfig(),j=!1,k={},
// NOTE: there are cases where the stylesheet link tag will be self-
// closing, so check for both cases
l=/<xhtml:link[^>]*>(\s*<\/xhtml:link>)?/i;
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Retrieve a SVG asset from the server
         * @param {string} objectType The type of data being requested
         * @param {number} pageNum The page number for which to request the SVG
         * @returns {$.Promise}    A promise with an additional abort() method that will abort the XHR request.
         */
get:function(a,b){var d,e=this.getURL(b);
// @NOTE: promise.then() creates a new promise, which does not copy
// custom properties, so we need to create a futher promise and add
// an object with the abort method as the new target
return k[b]?k[b]:(d=f.fetch(e,Ca.ASSET_REQUEST_RETRIES),k[b]=d.then(c).promise({abort:function(){d.abort(),k&&delete k[b]}}),k[b])},/**
         * Build and return the URL to the SVG asset for the specified page
         * @param   {number} pageNum The page number
         * @returns {string}         The URL
         */
getURL:function(a){var b=e.template(i.template.svg,{page:a});return i.url+b+i.queryString},/**
         * Cleanup the data-provider
         * @returns {void}
         */
destroy:function(){j=!0,e=f=h=g=i=k=null}}}),Ca.addDataProvider("page-text",function(a){/**
     * Process HTML text and return the embeddable result
     * @param   {string} text The original HTML text
     * @returns {string}      The processed HTML text
     * @private
     */
function b(a){if(!g){
// in the text layer, divs are only used for text boxes, so
// they should provide an accurate count
var b=d.countInStr(a,"<div");
// too many textboxes... don't load this page for performance reasons
// too many textboxes... don't load this page for performance reasons
// remove reference to the styles
return b>c?"":a=a.replace(/<link rel="stylesheet".*/,"")}}var c=256,d=a.getUtility("common"),e=a.getUtility("ajax"),f=a.getConfig(),g=!1,h={};
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Retrieve a text asset from the server
         * @param {string} objectType The type of data being requested
         * @param {number} pageNum The page number for which to request the text HTML
         * @returns {$.Promise}    A promise with an additional abort() method that will abort the XHR request.
         */
get:function(a,c){var d,f=this.getURL(c);
// @NOTE: promise.then() creates a new promise, which does not copy
// custom properties, so we need to create a futher promise and add
// an object with the abort method as the new target
return h[c]?h[c]:(d=e.fetch(f,Ca.ASSET_REQUEST_RETRIES),h[c]=d.then(b).promise({abort:function(){d.abort(),h&&delete h[c]}}),h[c])},/**
         * Build and return the URL to the HTML asset for the specified page
         * @param   {number} pageNum The page number
         * @returns {string}         The URL
         */
getURL:function(a){var b=d.template(f.template.html,{page:a});return f.url+b+f.queryString},/**
         * Cleanup the data-provider
         * @returns {void}
         */
destroy:function(){g=!0,d=e=f=h=null}}}),Ca.addDataProvider("stylesheet",function(a){/**
     * Process stylesheet text and return the embeddable result
     * @param   {string} text The original CSS text
     * @returns {string}      The processed CSS text
     * @private
     */
function b(a){
// @NOTE: There is a bug in IE that causes the text layer to
// not render the font when loaded for a second time (i.e.,
// destroy and recreate a viewer for the same document), so
// namespace the font-family so there is no collision
return e.ie&&(a=a.replace(/font-family:[\s\"\']*([\w-]+)\b/g,"$0-"+f.id)),a}var c,d=a.getUtility("ajax"),e=a.getUtility("browser"),f=a.getConfig();
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Retrieve the stylesheet.css asset from the server
         * @returns {$.Promise} A promise with an additional abort() method that will abort the XHR request.
         */
get:function(){if(c)return c;var a=d.fetch(this.getURL(),Ca.ASSET_REQUEST_RETRIES);
// @NOTE: promise.then() creates a new promise, which does not copy
// custom properties, so we need to create a futher promise and add
// an object with the abort method as the new target
return c=a.then(b).promise({abort:function(){a.abort(),c=null}})},/**
         * Build and return the URL to the stylesheet CSS
         * @returns {string}         The URL
         */
getURL:function(){var a=f.template.css;return f.url+a+f.queryString},/**
         * Cleanup the data-provider
         * @returns {void}
         */
destroy:function(){d=e=f=null,c=null}}}),Ca.addUtility("ajax",function(a){/**
     * Creates a request object to call the success/fail handlers on
     * @param {XMLHttpRequest} req The request object to wrap
     * @returns {Object} The request object
     * @private
     */
function c(a){var b,c,d;try{b=a.status,c=a.statusText,d=a.responseText}catch(e){b=0,c="",d=null}return{status:b,statusText:c,responseText:d,rawRequest:a}}/**
    * Returns true if the url is referencing a local file
    * @param   {string}  url The URL
    * @param   {Boolean}
    */
function d(a){return"file:"===l.parse(a).protocol}/**
     * Return true if the given status code looks successful
     * @param   {number}  status The http status code
     * @returns {Boolean}
     */
function e(a){return a>=200&&300>a||304===a}/**
     * Parse AJAX options
     * @param   {Object} options The options
     * @returns {Object}         The parsed options
     */
function f(a){return a=j.extend(!0,{},a||{}),a.method=a.method||"GET",a.headers=a.headers||[],a.data=a.data||"","string"!=typeof a.data&&(a.data=b.param(a.data),"GET"!==a.method&&(a.data=a.data,a.headers.push(["Content-Type","application/x-www-form-urlencoded"]))),a}/**
     * Set XHR headers
     * @param {XMLHttpRequest} req The request object
     * @param {Array} headers      Array of headers to set
     */
function g(a,b){var c;for(c=0;c<b.length;++c)a.setRequestHeader(b[c][0],b[c][1])}/**
     * Make an XHR request
     * @param   {string}   url     request URL
     * @param   {string}   method  request method
     * @param   {*}        data    request data to send
     * @param   {Array}    headers request headers
     * @param   {Function} success success callback function
     * @param   {Function} fail    fail callback function
     * @returns {XMLHttpRequest}   Request object
     * @private
     */
function h(a,b,c,f,h,i){var j=k.getXHR();return j.open(b,a,!0),j.onreadystatechange=function(){var b;if(4===j.readyState){// DONE
// remove the onreadystatechange handler,
// because it could be called again
// @NOTE: we replace it with a noop function, because
// IE8 will throw an error if the value is not of type
// 'function' when using ActiveXObject
j.onreadystatechange=function(){};try{b=j.status}catch(c){
// NOTE: IE (9?) throws an error when the request is aborted
return void i(j)}
// status is 0 for successful local file requests, so assume 200
0===b&&d(a)&&(b=200),e(b)?h(j):i(j)}},g(j,f),j.send(c),j}/**
     * Make an XDR request
     * @param   {string}   url     request URL
     * @param   {string}   method  request method
     * @param   {*}        data    request data to send
     * @param   {Function} success success callback function
     * @param   {Function} fail    fail callback function
     * @returns {XDomainRequest} Request object
     * @private
     */
function i(a,b,c,d,e){var f=k.getXDR();try{f.open(b,a),f.onload=function(){d(f)},
// NOTE: IE (8/9) requires onerror, ontimeout, and onprogress
// to be defined when making XDR to https servers
f.onerror=function(){e(f)},f.ontimeout=function(){e(f)},f.onprogress=function(){},f.send(c)}catch(g){return e({status:0,statusText:g.message})}return f}var j=a.getUtility("common"),k=a.getUtility("support"),l=a.getUtility("url");return{/**
         * Make a raw AJAX request
         * @param   {string}     url               request URL
         * @param   {Object}     [options]         AJAX request options
         * @param   {string}     [options.method]  request method, eg. 'GET', 'POST' (defaults to 'GET')
         * @param   {Array}      [options.headers] request headers (defaults to [])
         * @param   {*}          [options.data]    request data to send (defaults to null)
         * @param   {Function}   [options.success] success callback function
         * @param   {Function}   [options.fail]    fail callback function
         * @returns {XMLHttpRequest|XDomainRequest} Request object
         */
request:function(a,b){/**
             * Function to call on successful AJAX request
             * @returns {void}
             * @private
             */
function d(a){return j.isFn(g.success)&&g.success.call(c(a)),a}/**
             * Function to call on failed AJAX request
             * @returns {void}
             * @private
             */
function e(a){return j.isFn(g.fail)&&g.fail.call(c(a)),a}var g=f(b),m=g.method,n=g.data,o=g.headers;
// is XHR supported at all?
// is XHR supported at all?
// cross-domain request? check if CORS is supported...
return"GET"===m&&n&&(a=l.appendQueryParams(a,n),n=""),k.isXHRSupported()?l.isCrossDomain(a)&&!k.isCORSSupported()?i(a,m,n,d,e):h(a,m,n,o,d,e):g.fail({status:0,statusText:"AJAX not supported"})},/**
         * Fetch an asset, retrying if necessary
         * @param {string} url      A url for the desired asset
         * @param {number} retries  The number of times to retry if the request fails
         * @returns {$.Promise}     A promise with an additional abort() method that will abort the XHR request.
         */
fetch:function(a,c){/**
             * If there are retries remaining, make another attempt, otherwise
             * give up and reject the deferred
             * @param   {Object} error The error object
             * @returns {void}
             * @private
             */
function d(a){c>0?(
// if we have retries remaining, make another request
c--,f=e()):
// finally give up
i.reject(a)}/**
             * Make an AJAX request for the asset
             * @returns {XMLHttpRequest|XDomainRequest} Request object
             * @private
             */
function e(){return h.request(a,{success:function(){var b,c;if(!g){
// check status code for 202
if(c=this.rawRequest,202===this.status&&j.isFn(c.getResponseHeader)&&(b=parseInt(c.getResponseHeader("retry-after")),b>0))return void setTimeout(e,1e3*b);this.responseText?i.resolve(this.responseText):
// the response was empty, so consider this a
// failed request
d({error:"empty response",status:this.status,resource:a})}},fail:function(){g||d({error:this.statusText,status:this.status,resource:a})}})}var f,g=!1,h=this,i=b.Deferred();return f=e(),i.promise({abort:function(){g=!0,f.abort()}})}}}),Ca.addUtility("browser",function(){var a,b=navigator.userAgent,c={},d=/ip(hone|od|ad)/i.test(b),e=/android/i.test(b),f=/blackberry/i.test(b),g=/webos/i.test(b),h=/silk|kindle/i.test(b),i=/MSIE|Trident/i.test(b);return i&&(c.ie=!0,a=/MSIE/i.test(b)?/MSIE\s+(\d+\.\d+)/i.exec(b):/Trident.*rv[ :](\d+\.\d+)/.exec(b),c.version=a&&parseFloat(a[1]),c.ielt9=c.version<9,c.ielt10=c.version<10,c.ielt11=c.version<11),d&&(c.ios=!0,a=navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),c.version=a&&parseFloat(a[1]+"."+a[2])),c.mobile=/mobile/i.test(b)||d||e||f||g||h,c.firefox=/firefox/i.test(b),/safari/i.test(b)&&(c.chrome=/chrome/i.test(b),c.safari=!c.chrome),c.safari&&(a=navigator.appVersion.match(/Version\/(\d+(\.\d+)?)/),c.version=a&&parseFloat(a[1])),c}),Ca.addUtility("common",function(){var c=1.33333,d={};// IE 8+
return d.extend=b.extend,d.each=b.each,d.map=b.map,d.param=b.param,d.parseJSON=b.parseJSON,d.stringifyJSON="undefined"!=typeof a.JSON?a.JSON.stringify:function(){throw new Error("JSON.stringify not supported")},b.extend(d,{/**
         * Left bistect of list, optionally of property of objects in list
         * @param   {Array} list List of items to bisect
         * @param   {number} x    The number to bisect against
         * @param   {string} [prop] Optional property to check on list items instead of using the item itself
         * @returns {int}      The index of the bisection
         */
bisectLeft:function(a,b,c){for(var d,e,f=0,g=a.length;g>f;)e=Math.floor((f+g)/2),d=c?a[e][c]:a[e],b>d?f=e+1:g=e;return f},/**
         * Right bistect of list, optionally of property of objects in list
         * @param   {Array} list List of items to bisect
         * @param   {number} x    The number to bisect against
         * @param   {string} [prop] Optional property to check on list items instead of using the item itself
         * @returns {int}      The index of the bisection
         */
bisectRight:function(a,b,c){for(var d,e,f=0,g=a.length;g>f;)e=Math.floor((f+g)/2),d=c?a[e][c]:a[e],d>b?g=e:f=e+1;return f},/**
         * Clamp x to range [a,b]
         * @param   {number} x The value to clamp
         * @param   {number} a Low value
         * @param   {number} b High value
         * @returns {number}   The clamped value
         */
clamp:function(a,b,c){return b>a?b:a>c?c:a},/**
         * Returns the sign of the given number
         * @param   {number} value The number
         * @returns {number}       The sign (-1 or 1), or 0 if value === 0
         */
sign:function(a){var b=parseInt(a,10);return b?0>b?-1:1:b},/**
         * Returns true if the given value is a function
         * @param   {*} val Any value
         * @returns {Boolean} true if val is a function, false otherwise
         */
isFn:function(a){return"function"==typeof a},/**
         * Search for a specified value within an array, and return its index (or -1 if not found)
         * @param   {*} value       The value to search for
         * @param   {Array} array   The array to search
         * @returns {int}           The index of value in array or -1 if not found
         */
inArray:function(a,c){return d.isFn(c.indexOf)?c.indexOf(a):b.inArray(a,c)},/**
         * Constrains the range [low,high] to the range [0,max]
         * @param   {number} low  The low value
         * @param   {number} high The high value
         * @param   {number} max  The max value (0 is implicit min)
         * @returns {Object}      The range object containing min and max values
         */
constrainRange:function(a,b,c){var e=b-a;return 0>e?{min:-1,max:-1}:(a=d.clamp(a,0,c),b=d.clamp(a+e,0,c),e>b-a&&(a=d.clamp(b-e,0,c)),{min:a,max:b})},/**
         * Return the current time since epoch in ms
         * @returns {int} The current time
         */
now:function(){return(new Date).getTime()},/**
         * Creates and returns a new, throttled version of the passed function,
         * that, when invoked repeatedly, will only actually call the original
         * function at most once per every wait milliseconds
         * @param   {int}      wait Time to wait between calls in ms
         * @param   {Function} fn   The function to throttle
         * @returns {Function}      The throttled function
         */
throttle:function(a,b){function c(){i=d.now(),g=null,h=b.apply(e,f)}var e,f,g,h,i=0;return function(){var j=d.now(),k=a-(j-i);return e=this,f=arguments,0>=k?(clearTimeout(g),g=null,i=j,h=b.apply(e,f)):g||(g=setTimeout(c,k)),h}},/**
         * Creates and returns a new debounced version of the passed function
         * which will postpone its execution until after wait milliseconds
         * have elapsed since the last time it was invoked.
         * @param   {int}      wait Time to wait between calls in ms
         * @param   {Function} fn   The function to debounced
         * @returns {Function}      The debounced function
         */
debounce:function(a,b){function c(){var j=d.now()-h;a>j?g=setTimeout(c,a-j):(g=null,i=b.apply(e,f),e=f=null)}var e,f,g,h,i;return function(){return e=this,f=arguments,h=d.now(),g||(g=setTimeout(c,a)),i}},/**
         * Insert the given CSS string into the DOM and return the resulting DOMElement
         * @param   {string} css The CSS string to insert
         * @returns {Element}    The <style> element that was created and inserted
         */
insertCSS:function(a){var b=document.createElement("style"),c=document.createTextNode(a);try{b.setAttribute("type","text/css"),b.appendChild(c)}catch(d){}return document.getElementsByTagName("head")[0].appendChild(b),b},/**
         * Append a CSS rule to the given stylesheet
         * @param   {CSSStyleSheet} sheet The stylesheet object
         * @param   {string} selector     The selector
         * @param   {string} rule         The rule
         * @returns {int}                 The index of the new rule
         */
appendCSSRule:function(a,b,c){var d;return a.insertRule?a.insertRule(b+"{"+c+"}",a.cssRules.length):(d=a.addRule(b,c,a.rules.length),0>d&&(d=a.rules.length-1),d)},/**
         * Delete a CSS rule at the given index from the given stylesheet
         * @param   {CSSStyleSheet} sheet The stylesheet object
         * @param   {int} index           The index of the rule to delete
         * @returns {void}
         */
deleteCSSRule:function(a,b){a.deleteRule?a.deleteRule(b):a.removeRule(b)},/**
         * Get the parent element of the (first) text node that is currently selected
         * @returns {Element} The selected element
         * @TODO: return all selected elements
         */
getSelectedNode:function(){var b,c,d;return a.getSelection?(c=a.getSelection(),c.rangeCount&&(d=c.getRangeAt(0),d.collapsed||(b=c.anchorNode.parentNode))):document.selection&&(b=document.selection.createRange().parentElement()),b},/**
         * Cross-browser getComputedStyle, which is faster than jQuery.css
         * @param   {HTMLElement} el      The element
         * @returns {CSSStyleDeclaration} The computed styles
         */
getComputedStyle:function(b){return"getComputedStyle"in a?a.getComputedStyle(b):b.currentStyle},/**
         * Calculates the size of 1pt in pixels
         * @returns {number} The pixel value
         */
calculatePtSize:function(){var a,b,e=1e4,f=document.createElement("div");return f.style.display="block",f.style.position="absolute",f.style.width=e+"pt",document.body.appendChild(f),a=d.getComputedStyle(f),b=a&&a.width?parseFloat(a.width)/e:c,document.body.removeChild(f),b},/**
         * Count and return the number of occurrences of token in str
         * @param   {string} str   The string to search
         * @param   {string} token The string to search for
         * @returns {int}          The number of occurrences
         */
countInStr:function(a,b){for(var c,d=0;c=a.indexOf(b,c)+1;)d++;return d},/**
         * Apply the given data to a template
         * @param   {string} template  The template
         * @param   {Object} data The data to apply to the template
         * @returns {string}      The filled template
         */
template:function(a,b){var c;for(c in b)b.hasOwnProperty(c)&&(a=a.replace(new RegExp("\\{\\{"+c+"\\}\\}","g"),b[c]));return a}})}),Ca.addUtility("subpx",function(c){/**
     * Return true if subpixel rendering is supported
     * @returns {Boolean}
     * @private
     */
function d(){
// Test if subpixel rendering is supported
// @NOTE: jQuery.support.leadingWhitespace is apparently false if browser is IE6-8
if(!b.support.leadingWhitespace)return!1;
//span #1 - desired font-size: 12.5px
var c=b(g.template(f,{size:12.5})).appendTo(document.documentElement).get(0),d=b(c).css("font-size"),e=b(c).width();b(c).remove(),
//span #2 - desired font-size: 12.6px
c=b(g.template(f,{size:12.6})).appendTo(document.documentElement).get(0);var h=b(c).css("font-size"),i=b(c).width();
// is not mobile device?
// @NOTE(plai): Mobile WebKit supports subpixel rendering even though the browser fails the following tests.
// @NOTE(plai): When modifying these tests, make sure that these tests will work even when the browser zoom is changed.
// @TODO(plai): Find a better way of testing for mobile Safari.
if(b(c).remove(),!("ontouchstart"in a)){
//font sizes are the same? (Chrome and Safari will fail this)
if(d===h)return!1;
//widths are the same? (Firefox on Windows without GPU will fail this)
if(e===i)return!1}return!0}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var e="crocodoc-subpx-fix",f='<span style="font:{{size}}px serif; color:transparent; white-space:nowrap;">'+new Array(100).join("A")+"</span>",g=c.getUtility("common"),h=d();
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Apply the subpixel rendering fix to the given element if necessary.
         * @NOTE: Fix is only applied if the "zoom" CSS property exists
         *        (ie., this fix is never applied in Firefox)
         * @param   {Element} el The element
         * @returns {Element} The element
         */
fix:function(a){if(!h&&void 0!==document.body.style.zoom){var c=b("<div>").addClass(e);b(a).wrap(c)}return a},/**
         * Is sub-pixel text rendering supported?
         * @param   {void}
         * @returns {boolean} true if sub-pixel tex rendering is supported
         */
isSubpxSupported:function(){return h}}}),Ca.addUtility("support",function(){/**
     * Helper function to get the proper vendor property name
     * (`transition` => `WebkitTransition`)
     * @param {string} prop The property name to test for
     * @returns {string|boolean} The vendor-prefixed property name or false if the property is not supported
     */
function b(a){var b,e,f,g=document.createElement("div");
// Handle unprefixed versions (FF16+, for example)
if(a in g.style)return a;if(b=a.charAt(0).toUpperCase()+a.substr(1),a in g.style)return a;for(e=0;e<d.length;++e)if(f=d[e]+b,f in g.style)return 0===f.indexOf("ms")&&(f="-"+f),c(f);return!1}/**
     * Converts a camelcase string to a dasherized string.
     * (`marginLeft` => `margin-left`)
     * @param {stirng} str The camelcase string to convert
     * @returns {string} The dasherized string
     */
function c(a){return a.replace(/([A-Z])/g,function(a){return"-"+a.toLowerCase()})}var d=["Moz","Webkit","O","ms"],e=null,f=null;return{svg:document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"),csstransform:b("transform"),csstransition:b("transition"),csszoom:b("zoom"),/**
         * Return true if XHR is supported
         * @returns {boolean}
         */
isXHRSupported:function(){return null===e&&(e=!!this.getXHR()),e},/**
         * Return true if XHR is supported and is CORS-enabled
         * @returns {boolean}
         */
isCORSSupported:function(){return null===f&&(f=this.isXHRSupported()&&"withCredentials"in this.getXHR()),f},/**
         * Return true if XDR is supported
         * @returns {boolean}
         */
isXDRSupported:function(){return"undefined"!=typeof a.XDomainRequest},/**
         * Get a XHR object
         * @returns {XMLHttpRequest} An XHR object
         */
getXHR:function(){if(a.XMLHttpRequest)return new a.XMLHttpRequest;try{return new ActiveXObject("MSXML2.XMLHTTP.3.0")}catch(b){return null}},/**
         * Get a CORS-enabled request object
         * @returns {XMLHttpRequest|XDomainRequest} The request object
         */
getXDR:function(){return this.isXDRSupported()?new a.XDomainRequest:null}}}),Ca.addUtility("url",function(b){var c,d=b.getUtility("browser");return{/**
         * Return the current page's URL
         * @returns {string} The current URL
         */
getCurrentURL:function(){return a.location.href},/**
         * Make the given path absolute
         *  - if path doesn't contain protocol and domain, prepend the current protocol and domain
         *  - if the path is relative (eg. doesn't begin with /), also fill in the current path
         * @param   {string} path The path to make absolute
         * @returns {string}      The absolute path
         */
makeAbsolute:function(a){return this.parse(a).href},/**
         * Returns true if the given url is external to the current domain
         * @param   {string}  url The URL
         * @returns {Boolean} Whether or not the url is external
         */
isCrossDomain:function(a){var b=this.parse(a);
// IE7 does not properly parse relative URLs, so the hostname is empty
// IE7 does not properly parse relative URLs, so the hostname is empty
return c||(c=this.parse(this.getCurrentURL())),b.hostname?b.protocol!==c.protocol||b.hostname!==c.hostname||b.port!==c.port:!1},/**
         * Append a query parameters string to the given URL
         * @param   {string} url The URL
         * @param   {string} str The query parameters
         * @returns {string}     The new URL
         */
appendQueryParams:function(a,b){return a.indexOf("?")>-1?a+"&"+b:a+"?"+b},/**
         * Parse a URL into protocol, host, port, etc
         * @param   {string} url The URL to parse
         * @returns {object}     The parsed URL parts
         */
parse:function(a){var b,c=document.createElement("a");
// @NOTE: IE does not automatically parse relative urls,
// but requesting href back from the <a> element will return
// an absolute URL, which can then be fed back in to get the
// expected result. WTF? Yep!
// @NOTE: IE does not include the preceding '/' in pathname
return c.href=a,d.ie&&a!==c.href&&(a=c.href,c.href=a),b=c.pathname,/^\//.test(b)||(b="/"+b),{href:c.href,protocol:c.protocol,host:c.host,hostname:c.hostname,port:c.port,pathname:b,hash:c.hash,search:c.search}}}}),Ca.addComponent("controller-paged",function(a){/**
     * Validates the config options
     * @returns {void}
     * @private
     */
function c(){var a=j.metadata;j.numPages=a.numpages,j.pageStart?j.pageStart<0&&(j.pageStart=a.numpages+j.pageStart):j.pageStart=1,j.pageStart=n.clamp(j.pageStart,1,a.numpages),j.pageEnd?j.pageEnd<0&&(j.pageEnd=a.numpages+j.pageEnd):j.pageEnd=a.numpages,j.pageEnd=n.clamp(j.pageEnd,j.pageStart,a.numpages),j.numPages=j.pageEnd-j.pageStart+1}/**
     * Create the html skeleton for the viewer and pages
     * @returns {void}
     * @private
     */
function d(){var a,c,d,e,f,g,h,i,k=n.calculatePtSize(),l=j.metadata.dimensions,m="";for(
// adjust page scale if the pages are too small/big
// it's adjusted so 100% == DOCUMENT_100_PERCENT_WIDTH px;
j.pageScale=P/(l.width*k),
// add zoom levels to accomodate the scale
d=j.zoomLevels[j.zoomLevels.length-1],e=3/j.pageScale;e>d;)d+=d/2,j.zoomLevels.push(d);
// create skeleton
for(l.exceptions=l.exceptions||{},a=j.pageStart-1;a<j.pageEnd;a++)c=a+1,c in l.exceptions?(f=l.exceptions[c].width,g=l.exceptions[c].height):(f=l.width,g=l.height),h=f*k,i=g*k,h*=j.pageScale,i*=j.pageScale,m+=n.template(Ca.pageTemplate,{w:h,h:i});
// insert skeleton and keep a reference to the jq object
j.$pages=b(m).appendTo(j.$doc)}/**
     * Return the expected conversion status of the given page index
     * @param   {int} pageIndex The page index
     * @returns {string}        The page status
     */
function e(a){return j.conversionIsComplete||0===a&&j.autoloadFirstPage?ca:ba}/**
     * Create and init all necessary page component instances
     * @returns {void}
     * @private
     */
function f(){var b,c,d=[],f=j.pageStart-1,h=j.pageEnd,i=g();
//initialize pages
for(b=f;h>b;b++)c=a.createComponent("page"),c.init(j.$pages.eq(b-f),{index:b,status:e(b),enableLinks:j.enableLinks,links:i[b],pageScale:j.pageScale,useSVG:j.useSVG}),d.push(c);j.pages=d}/**
     * Returns all links associated with the given page
     * @param  {int} page The page
     * @returns {Array}   Array of links
     * @private
     */
function g(){var a,b,c,d,
// the starting and ending page *numbers* (not indexes)
e=j.pageStart,f=j.pageEnd,g=j.metadata.links||[],h=[];
// NOTE:
// link.pagenum is the page the link resides on
// link.destination.pagenum is the page the link links to
for(a=0,b=j.metadata.numpages;b>a;++a)h[a]=[];for(a=0,b=g.length;b>a;++a)if(c=g[a],!(c.pagenum<e||c.pagenum>f)){if(c.destination){if(d=c.destination.pagenum,e>d||d>f)
// destination is outside the enabled page range
continue;
// subtract the number of pages cut off from the beginning
c.destination.pagenum=d-(e-1)}h[c.pagenum-1].push(c)}return h}/**
     * Handle mouseup events
     * @returns {void}
     * @private
     */
function h(){i()}/**
     * Check if text is selected on any page, and if so, add a css class to that page
     * @returns {void}
     * @TODO(clakenen): this method currently only adds the selected class to one page,
     * so we should modify it to add the class to all pages with selected text
     * @private
     */
function i(){var a=n.getSelectedNode(),c=b(a).closest("."+v);k.find("."+l).removeClass(l),a&&k.has(a)&&c.addClass(l)}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var j,k,m,n=a.getUtility("common");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the controller
         * @returns {void}
         */
init:function(){j=a.getConfig(),k=j.$el,b(document).on("mouseup",h),c(),d(),f(),m=a.createComponent("lazy-loader"),m.init(j.pages)},/**
         * Destroy the viewer-base component
         * @returns {void}
         */
destroy:function(){
// remove document event handlers
b(document).off("mouseup",h)}}}),Ca.addComponent("controller-text",function(a){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c;
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the controller
         * @returns {void}
         */
init:function(){var d=a.getConfig();d.$textContainer=b(),
// we can just load the text immediately
c=a.get("page-text",1).then(function(a){
// the viewport could be window in useWindowAsViewport, so get
// the real viewport div
var c=d.$doc.parent();d.$doc=b(a),c.html(d.$doc)})},/**
         * Destroy the viewer-base component
         * @returns {void}
         */
destroy:function(){c.abort()}}}),Ca.addComponent("dragger",function(c){/**
     * Handle mousemove events
     * @param   {Event} event The event object
     * @returns {void}
     */
function d(a){g.scrollTop(h.top-(a.clientY-i.y)),g.scrollLeft(h.left-(a.clientX-i.x)),a.preventDefault()}/**
     * Handle mouseup events
     * @param   {Event} event The event object
     * @returns {void}
     */
function e(a){c.broadcast("dragend"),j.off("mousemove",d),j.off("mouseup",e),a.preventDefault()}/**
     * Handle mousedown events
     * @param   {Event} event The event object
     * @returns {void}
     */
function f(a){c.broadcast("dragstart"),h={top:g.scrollTop(),left:g.scrollLeft()},i={x:a.clientX,y:a.clientY},j.on("mousemove",d),j.on("mouseup",e),a.preventDefault()}var g,h,i,j=b(a);
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the scroller component
         * @param   {Element} el The Element
         * @returns {void}
         */
init:function(a){g=b(a),g.on("mousedown",f)},/**
         * Destroy the scroller component
         * @returns {void}
         */
destroy:function(){g.off("mousedown",f),g.off("mousemove",d),j.off("mouseup",e)}}}),Ca.addComponent("layout-base",function(b){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c=b.getUtility("common");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{messages:["resize","scroll","scrollend"],/**
         * Handle framework messages
         * @param {string} name The name of the message
         * @param {Object} data The related data for the message
         * @returns {void}
         */
onmessage:function(a,b){switch(a){case"resize":this.handleResize(b);break;case"scroll":this.handleScroll(b);break;case"scrollend":this.handleScrollEnd(b)}},/**
         * Initialize the Layout component
         * @returns {void}
         */
init:function(){var a=b.getConfig();this.config=a,
// shortcut references to jq DOM objects
this.$el=a.$el,this.$doc=a.$doc,this.$viewport=a.$viewport,this.$pages=a.$pages,this.numPages=a.numPages,
// add the layout css class
this.layoutClass=s+a.layout,this.$el.addClass(this.layoutClass),this.initState()},/**
         * Initalize the state object
         * @returns {void}
         */
initState:function(){var b=this.$viewport[0],c=b;
// use the documentElement for viewport dimensions
// if we are using the window as the viewport
b===a&&(c=document.documentElement),
// setup initial state
this.state={scrollTop:b.scrollTop,scrollLeft:b.scrollLeft,viewportDimensions:{clientWidth:c.clientWidth,clientHeight:c.clientHeight,offsetWidth:c.offsetWidth,offsetHeight:c.offsetHeight},zoomState:{zoom:1,prevZoom:0,zoomMode:null},initialWidth:0,initialHeight:0,totalWidth:0,totalHeight:0},this.zoomLevels=[]},/**
         * Destroy the Layout component
         * @returns {void}
         */
destroy:function(){this.$doc.removeAttr("style"),this.$el.removeClass(this.layoutClass)},/**
         * Set the zoom level for the layout (to be implemented)
         */
setZoom:function(){},/**
         * Calculate the next zoom level for zooming in or out
         * @param   {string} direction Can be either Crocodoc.ZOOM_IN or Crocodoc.ZOOM_OUT
         * @returns {number|boolean} The next zoom level or false if the viewer cannot be
         *                               zoomed in the given direction
         */
calculateNextZoomLevel:function(a){var b,c=!1,d=this.state.zoomState.zoom,e=this.zoomLevels;if(a===Ca.ZOOM_IN){for(b=0;b<e.length;++b)if(e[b]>d){c=e[b];break}}else if(a===Ca.ZOOM_OUT)for(b=e.length-1;b>=0;--b)if(e[b]<d){c=e[b];break}return c},/**
         * Returns true if the layout is currently draggable
         * (in this case that means that the viewport is scrollable)
         * @returns {Boolean} Whether this layout is draggable
         */
isDraggable:function(){var a=this.state;return a.viewportDimensions.clientHeight<a.totalHeight||a.viewportDimensions.clientWidth<a.totalWidth},/**
         * Scrolls by the given pixel amount from the current location
         * @param  {int} left Left offset to scroll to
         * @param  {int} top  Top offset to scroll to
         * @returns {void}
         */
scrollBy:function(a,b){a=parseInt(a,10)||0,b=parseInt(b,10)||0,this.scrollToOffset(a+this.state.scrollLeft,b+this.state.scrollTop)},/**
         * Scroll to the given left and top offset
         * @param   {int} left The left offset
         * @param   {int} top  The top offset
         * @returns {void}
         */
scrollToOffset:function(a,b){this.$viewport.scrollLeft(a),this.$viewport.scrollTop(b)},/**
         * Handle scroll messages
         * @param   {Object} data Object containing scrollTop and scrollLeft of the viewport
         * @returns {void}
         */
handleScroll:function(a){this.state.scrollTop=a.scrollTop,this.state.scrollLeft=a.scrollLeft},/**
         * Handle resize messages (to be implemented in layout)
         */
handleResize:function(){},/**
         * Handle scrollend messages (to be implemented in layout)
         */
handleScrollEnd:function(){},/**
         * Force a full layout update (to be implemented in layout)
         */
update:function(){},/**
         * Focuses the viewport so it can be natively scrolled with the keyboard
         * @returns {void}
         */
focus:function(){this.$viewport.focus()},/**
         * Shortcut method to extend this layout
         * @param   {Object} layout The layout mixins
         * @returns {Object}        The extended layout
         */
extend:function(a){return c.extend({},this,a)}}}),Ca.addComponent("layout-"+Z,["layout-paged"],function(a,b){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c=a.getUtility("common"),d=a.getUtility("browser");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return b.extend({/**
         * Calculate the numeric value for zoom 'auto' for this layout mode
         * @returns {float} The zoom value
         */
calculateZoomAutoValue:function(){var a=this.state,b=this.calculateZoomValue(Q),c=this.calculateZoomValue(R);
// landscape
// landscape
return a.widestPage.actualWidth>a.tallestPage.actualHeight?Math.min(b,c):d.mobile?c:Math.min(1,c)},/**
         * Calculate which page is currently the "focused" page.
         * In horizontal mode, this is the page farthest to the left,
         * where at least half of the page is showing.
         * @returns {int} The current page
         */
calculateCurrentPage:function(){var a,b,d=this.state,e=d.pages;return a=c.bisectRight(e,d.scrollLeft,"x0")-1,b=c.bisectRight(e,d.scrollLeft+e[a].width/2,"x0")-1,1+b},/**
         * Calculates the next page
         * @returns {int} The next page number
         */
calculateNextPage:function(){return this.state.currentPage+1},/**
         * Calculates the previous page
         * @returns {int} The previous page number
         */
calculatePreviousPage:function(){return this.state.currentPage-1},/**
         * Handle resize mesages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleResize:function(a){b.handleResize.call(this,a),this.updateCurrentPage()},/**
         * Handle scroll mesages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleScroll:function(a){b.handleScroll.call(this,a),this.updateCurrentPage()},/**
         * Updates the layout elements (pages, doc, etc) CSS
         * appropriately for the current zoom level
         * @returns {void}
         */
updateLayout:function(){var a=this.state,b=a.zoomState,c=b.zoom,d=a.sumWidths,e=Math.floor(a.tallestPage.totalActualHeight*c),f=Math.max(d,a.viewportDimensions.clientWidth),g=Math.max(e,a.viewportDimensions.clientHeight);this.$doc.css({height:g,lineHeight:g+"px",width:f})}})}),Ca.addComponent("layout-paged",["layout-base"],function(a,b){/**
     * Apply a zoom transform to the layout using width/height
     * (using width/height instead)
     * @param   {float} zoom The zoom value
     * @returns {void}
     * @private
     */
function c(a,b){
// manually resize pages width/height
var c,d,g,h,i=a.state,j="."+a.config.namespace+" ."+C,k=a.config.stylesheet,l=i.pages,m=b*a.config.pageScale,n=100/m;
// update width/height/padding on all pages
for(
// apply css transform or zoom to autoscale layer (eg., text, links, user content)
h=f.csstransform?f.csstransform+":scale("+m+");width:"+n+"%;height:"+n+"%;":f.csszoom?"zoom:"+m:"",i.previousStyleIndex&&e.deleteCSSRule(k,i.previousStyleIndex),i.previousStyleIndex=e.appendCSSRule(k,j,h),c=0,d=l.length;d>c;++c)g=l[c],a.$pages.eq(c).css({width:g.actualWidth*b,height:g.actualHeight*b,paddingTop:g.paddingTop*b,paddingRight:g.paddingRight*b,paddingBottom:g.paddingBottom*b,paddingLeft:g.paddingLeft*b})}/**
     * Get the maximum y1 value for pages in the current row
     * (or Infinity if there are no pages in the current row yet)
     * @param {Array} pages Array of pages to search
     * @param {Array} row   Array of page indexes (i.e., the row)
     * @returns {number} The max y1 value
     * @private
     */
function d(a,b){if(!b||0===b.length)return 1/0;var c=e.map(b,function(b){return a[b].y1});return Math.max.apply(Math,c)}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var e=a.getUtility("common"),f=a.getUtility("support");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return b.extend({/**
         * Initialize the Layout component
         * @returns {void}
         */
init:function(){b.init.call(this),this.updatePageStates(),this.updateZoomLevels()},/**
         * Initalize the state object
         * @returns {void}
         */
initState:function(){b.initState.call(this),e.extend(this.state,{pages:[],widestPage:{index:0,actualWidth:0},tallestPage:{index:0,actualHeight:0},sumWidths:0,sumHeights:0,rows:[],currentPage:null,visiblePages:[],fullyVisiblePages:[]})},/**
         * Destroy the Layout component
         * @returns {void}
         */
destroy:function(){b.destroy.call(this),this.$pages.css("padding","")},/**
         * Force a full layout update
         */
update:function(){this.updatePageStates(!0),this.setZoom()},/**
         * Set the zoom level for the layout
         * @param {float|string} val The zoom level (float or one of the zoom constants)
         */
setZoom:function(b){var c,d,f=this.state,g=this.parseZoomValue(b),h=f.zoomState,i=h.zoom;c=this.calculateZoomMode(b,g),g=e.clamp(g,f.minZoom,f.maxZoom),a.broadcast("beforezoom",e.extend({page:f.currentPage,visiblePages:e.extend([],f.visiblePages),fullyVisiblePages:e.extend([],f.fullyVisiblePages)},h)),h.prevZoom=i,h.zoom=g,h.zoomMode=c,this.applyZoom(g),h.canZoomIn=this.calculateNextZoomLevel(Ca.ZOOM_IN)!==!1,h.canZoomOut=this.calculateNextZoomLevel(Ca.ZOOM_OUT)!==!1,this.updatePageStates(),this.updateLayout(),d=b===Ca.ZOOM_AUTO||b===Ca.ZOOM_FIT_WIDTH||b===Ca.ZOOM_FIT_HEIGHT,this.updateScrollPosition(d),this.updatePageStates(),this.updateVisiblePages(!0),a.broadcast("zoom",e.extend({page:f.currentPage,visiblePages:e.extend([],f.visiblePages),fullyVisiblePages:e.extend([],f.fullyVisiblePages),isDraggable:this.isDraggable()},h))},/**
         * Parse the given zoom value into a number to zoom to.
         * @param   {float|string} val The zoom level (float or one of the zoom constants)
         * @returns {float} The parsed zoom level
         */
parseZoomValue:function(a){var b=parseFloat(a),c=this.state,d=c.zoomState,e=d.zoom,f=e;
// number
if(b)f=b;else switch(a){case Ca.ZOOM_FIT_WIDTH:
// falls through
case Ca.ZOOM_FIT_HEIGHT:
// falls through
case Ca.ZOOM_AUTO:f=this.calculateZoomValue(a);break;case Ca.ZOOM_IN:
// falls through
case Ca.ZOOM_OUT:f=this.calculateNextZoomLevel(a)||e;break;
// bad mode or no value
default:
// if there hasn't been a zoom set yet
f=e?d.zoomMode?this.calculateZoomValue(d.zoomMode):e:this.calculateZoomValue(this.config.zoom||Ca.ZOOM_AUTO)}return f},/**
         * Calculates the new zoomMode given the input val and the parsed zoom value
         * @param   {float|string} val  The input zoom value
         * @param   {float} parsedZoom  The parsed zoom value
         * @returns {string|null}       The new zoom move
         */
calculateZoomMode:function(a,b){
// check if we landed on a named mode
switch(b){case this.calculateZoomValue(Ca.ZOOM_AUTO):
// if the value passed is a named zoom mode, use that, because
// fitheight and fitwidth can sometimes clash with auto (else use auto)
// if the value passed is a named zoom mode, use that, because
// fitheight and fitwidth can sometimes clash with auto (else use auto)
return"string"!=typeof a||a!==Ca.ZOOM_FIT_WIDTH&&a!==Ca.ZOOM_FIT_HEIGHT?Ca.ZOOM_AUTO:a;case this.calculateZoomValue(Ca.ZOOM_FIT_WIDTH):return Ca.ZOOM_FIT_WIDTH;case this.calculateZoomValue(Ca.ZOOM_FIT_HEIGHT):return Ca.ZOOM_FIT_HEIGHT;default:return null}},/**
         * Update zoom levels and the min and max zoom
         * @returns {void}
         */
updateZoomLevels:function(){/**
             * Return true if we should use this zoom level
             * @param   {number} zoomLevel The zoom level to consider
             * @returns {boolean}          True if we should keep this level
             * @private
             */
function a(a){var b=c/a;
// remove duplicates
// remove duplicates
// keep anything that is within the similarity threshold
// check if it's a preset
return a===c?!1:la>b?!0:e.inArray(a,i)>-1&&ma>b?!0:!1}var b,c,d=this.config.zoomLevels.slice()||[1],f=this.calculateZoomValue(Ca.ZOOM_AUTO),g=this.calculateZoomValue(Ca.ZOOM_FIT_WIDTH),h=this.calculateZoomValue(Ca.ZOOM_FIT_HEIGHT),i=[g,h];for(
// update min and max zoom before adding presets into the mix
// because presets should not be able to override min/max zoom
this.state.minZoom=this.config.minZoom||d[0],this.state.maxZoom=this.config.maxZoom||d[d.length-1],
// if auto is not the same as fitWidth or fitHeight,
// add it as a possible next zoom
f!==g&&f!==h&&i.push(f),d=d.concat(i),d.sort(function(a,b){return a-b}),this.zoomLevels=[],c=0,b=0;b<d.length;++b)a(d[b])&&(c=d[b],this.zoomLevels.push(c))},/**
         * Calculate the numeric value for a given zoom mode (or return the value if it's already numeric)
         * @param   {string} mode The mode to zoom to
         * @returns {float}       The zoom value
         */
calculateZoomValue:function(a){var b=this.state,c=parseFloat(a);return c?c:a===Ca.ZOOM_FIT_WIDTH?b.viewportDimensions.clientWidth/b.widestPage.totalActualWidth:a===Ca.ZOOM_FIT_HEIGHT?b.viewportDimensions.clientHeight/b.tallestPage.totalActualHeight:a===Ca.ZOOM_AUTO?this.calculateZoomAutoValue():b.zoomState.zoom},/**
         * Apply the given zoom to the pages
         * @param   {float} zoom The zoom value
         * @returns {void}
         */
applyZoom:function(a){c(this,a)},/**
         * Scroll to the given value (page number or one of the scroll constants)
         * @param   {int|string} val  The value to scroll to
         * @returns {void}
         */
scrollTo:function(a){var b=this.state,c=parseInt(a,10);if("string"==typeof a){if(a===Ca.SCROLL_PREVIOUS&&b.currentPage>1)c=this.calculatePreviousPage();else if(a===Ca.SCROLL_NEXT&&b.currentPage<this.numPages)c=this.calculateNextPage();else if(!c)return}else if(!c&&0!==c)
// pageNum is not a number
return;c=e.clamp(c,1,this.numPages),this.scrollToPage(c)},/**
         * Scroll to the given page number
         * @param   {int} page The page number to scroll to
         * @returns {void}
         */
scrollToPage:function(a){var b=this.calculateScrollPositionForPage(a);this.scrollToOffset(b.left,b.top)},/**
         * Calculate which page is currently the "focused" page.
         * By default, it's just the state's current page.
         * @NOTE: this method will be overridden in most layouts.
         * @returns {int} The current page
         */
calculateCurrentPage:function(){return this.state.currentPage},/**
         * Given a page number, return an object with top and left properties
         * of the scroll position for that page
         * @param   {int} pageNum The page number
         * @returns {Object}      The scroll position object
         */
calculateScrollPositionForPage:function(a){var b=e.clamp(a-1,0,this.numPages-1),c=this.state.pages[b];return{top:c.y0,left:c.x0}},/**
         * Calculates the current range of pages that are visible
         * @returns {Object} Range object with min and max values
         */
calculateVisibleRange:function(){var a=this.state,b=a.pages,c=a.viewportDimensions.clientHeight,d=a.viewportDimensions.clientWidth;
// no pages are visible, but this case breaks the logic below,
// becasue page widths/heights will also be 0
if(0===d||0===c)return{min:-1,max:-1};var f=a.scrollTop,g=f+c,h=a.scrollLeft,i=h+d,j=e.bisectLeft(b,f,"y1"),k=e.bisectRight(b,g,"y0")-1,l=e.bisectLeft(b,h,"x1"),m=e.bisectRight(b,i,"x0")-1,n=Math.max(l,j),o=Math.min(m,k);return e.constrainRange(n,o,this.numPages-1)},/**
         * Calculates the current range of pages that are fully visible
         * @returns {Object} Range object with min and max values
         * @NOTE: the only difference between this and calculateVisibleRange is
         * the bisectLeft/Right section below uses the opposite fields in the
         * page objects to test against. (TODO) Consider refactoring this to
         * make it a little simpler...
         */
calculateFullyVisibleRange:function(){var a=this.state,b=a.pages,c=a.viewportDimensions.clientHeight,d=a.viewportDimensions.clientWidth;
// no pages are visible, but this case breaks the logic below
// becasue page widths/heights will also be 0
if(0===d||0===c)return{min:-1,max:-1};var f=a.scrollTop,g=f+c,h=a.scrollLeft,i=h+d,j=e.bisectLeft(b,f,"y0"),k=e.bisectRight(b,g,"y1")-1,l=e.bisectLeft(b,h,"x0"),m=e.bisectRight(b,i,"x1")-1,n=Math.max(l,j),o=Math.min(m,k);return e.constrainRange(n,o,this.numPages-1)},/**
         * Set the current page, update the visible pages, and broadcast a
         * pagefocus  message if the given page is not already the current page
         * @param {int} page The page number
         */
setCurrentPage:function(b){var c=this.state;c.currentPage!==b?(
// page has changed
c.currentPage=b,this.updateVisiblePages(),a.broadcast("pagefocus",{page:c.currentPage,numPages:this.numPages,visiblePages:e.extend([],c.visiblePages),fullyVisiblePages:e.extend([],c.fullyVisiblePages)})):
// still update visible pages!
this.updateVisiblePages()},/**
         * Calculate and update which pages are visible,
         * possibly updating CSS classes on the pages
         * @param {boolean} updateClasses Wheter to update page CSS classes as well
         * @returns {void}
         */
updateVisiblePages:function(a){var b,c,d,e=this.state,f=this.calculateVisibleRange(),g=this.calculateFullyVisibleRange();for(e.visiblePages.length=0,e.fullyVisiblePages.length=0,b=0,c=this.$pages.length;c>b;++b)d=this.$pages.eq(b),b<f.min||b>f.max?a&&d.hasClass(F)&&d.removeClass(F):(a&&!d.hasClass(F)&&d.addClass(F),e.visiblePages.push(b+1)),b>=g.min&&b<=g.max&&e.fullyVisiblePages.push(b+1)},/**
         * Update page positions, sizes, and rows
         * @param {boolean} [forceUpdatePaddings] If true, force update page paddings
         * @returns {void}
         */
updatePageStates:function(a){var b,c,e,f,g,h=this.state,i=h.pages,j=h.rows,k=this.$viewport.scrollTop(),l=this.$viewport.scrollLeft(),m=0,n=0,o=0,p=0;
// update the x/y positions and sizes of each page
// this is basically used as a cache, since accessing the DOM is slow
for(j.length=h.sumWidths=h.sumHeights=h.totalWidth=h.totalHeight=0,h.widestPage.totalActualWidth=h.tallestPage.totalActualHeight=0,b=0,c=this.$pages.length;c>b;++b)g=this.$pages.eq(b),f=g[0],e=i[b],(!e||a)&&(g.css("padding",""),e={index:b,paddingLeft:parseFloat(g.css(ja)),paddingRight:parseFloat(g.css(ia)),paddingTop:parseFloat(g.css(ha)),paddingBottom:parseFloat(g.css(ka))}),e.actualWidth||(e.actualWidth=parseFloat(f.getAttribute("data-width"))),e.actualHeight||(e.actualHeight=parseFloat(f.getAttribute("data-height"))),e.totalActualWidth=e.actualWidth+e.paddingLeft+e.paddingRight,e.totalActualHeight=e.actualHeight+e.paddingTop+e.paddingBottom,e.width=f.offsetWidth,e.height=f.offsetHeight,e.x0=f.offsetLeft,e.y0=f.offsetTop,e.x1=e.width+e.x0,e.y1=e.height+e.y0,n&&d(i,j[m])<=e.y0+2&&m++,n=e.y1,j[m]||(j[m]=[]),e.totalActualWidth>h.widestPage.totalActualWidth&&(h.widestPage=e),e.totalActualHeight>h.tallestPage.totalActualHeight&&(h.tallestPage=e),h.sumWidths+=e.width,h.sumHeights+=e.height,e.rowIndex=m,i[b]=e,j[m].push(b),i[o].x0+i[o].width<e.x0+e.width&&(o=b),i[p].y0+i[p].height<e.y0+e.height&&(p=b);h.totalWidth=i[o].x0+i[o].width,h.totalHeight=i[p].y0+i[p].height,h.scrollTop=k,h.scrollLeft=l,this.setCurrentPage(this.calculateCurrentPage())},/**
         * Calculate and update the current page
         * @returns {void}
         */
updateCurrentPage:function(){var a=this.calculateCurrentPage();this.setCurrentPage(a)},/**
         * Handle resize messages
         * @param   {Object} data Object containing width and height of the viewport
         * @returns {void}
         */
handleResize:function(a){var b=this.state.zoomState.zoomMode;this.state.viewportDimensions=a,this.updateZoomLevels(),this.setZoom(b)},/**
         * Handle scrollend messages (forwarded to handleScroll)
         * @param   {Object} data Object containing scrollTop and scrollLeft of the viewport
         * @returns {void}
         */
handleScrollEnd:function(a){
// update CSS classes
this.$doc.find("."+t).removeClass(t),this.$pages.eq(this.state.currentPage-1).addClass(t),this.updateVisiblePages(!0),this.handleScroll(a)},/**
         * Update the scroll position after a zoom
         * @param {bool} shouldNotCenter Whether or not the scroll position
         *                               should be updated to center the new
         *                               zoom level
         * @returns {void}
         */
updateScrollPosition:function(a){var b,c,d=this.state,e=d.zoomState,f=e.zoom/e.prevZoom;b=d.scrollLeft*f,c=d.scrollTop*f,a!==!0&&(c+=d.viewportDimensions.offsetHeight*(f-1)/2,b+=d.viewportDimensions.offsetWidth*(f-1)/2),this.scrollToOffset(b,c)},/** MUST BE IMPLEMENTED IN LAYOUT **/
updateLayout:function(){},calculateZoomAutoValue:function(){return 1},calculateNextPage:function(){return 1},calculatePreviousPage:function(){return 1}})}),Ca.addComponent("layout-"+_,["layout-"+$],function(a,b){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c=a.getUtility("common");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return b.extend({/**
         * Initialize the presentation-two-page layout component
         * @returns {void}
         */
init:function(){this.twoPageMode=!0,b.init.call(this)},/**
         * Calculates the next page
         * @returns {int} The next page number
         */
calculateNextPage:function(){return this.state.currentPage+2},/**
         * Calculates the previous page
         * @returns {int} The previous page number
         */
calculatePreviousPage:function(){return this.state.currentPage-2},/**
         * Calculate the numeric value for a given zoom mode (or return the value if it's already numeric)
         * @param   {string} mode The mode to zoom to
         * @returns {float}       The zoom value
         */
calculateZoomValue:function(a){var c=b.calculateZoomValue.call(this,a);return a===Q&&(c/=2),c},/**
         * Scroll to the given page number
         * @param   {int} page The page number to scroll to
         * @returns {void}
         */
scrollToPage:function(a){
// pick the left page
b.scrollToPage.call(this,a-(a+1)%2)},/**
         * Calculates the current range of pages that are visible
         * @returns {Object} Range object with min and max values
         */
calculateVisibleRange:function(){var a=this.state.currentPage-1,b=a+1;return c.constrainRange(a,b,this.numPages)},/**
         * Calculates the current range of pages that are fully visible
         * @NOTE: this can be incorrect for presentations that are zoomed in
         * past the size of the viewport... I'll fix it if it becomes an issue
         * @returns {Object} Range object with min and max values
         */
calculateFullyVisibleRange:function(){return this.calculateVisibleRange()}})}),Ca.addComponent("layout-"+$,["layout-paged"],function(a,b){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c=a.getUtility("common");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return b.extend({/**
         * Initialize the presentation layout component
         * @returns {void}
         */
init:function(){b.init.call(this),this.updatePageMargins(),this.updatePageClasses()},/**
         * Destroy the component
         * @returns {void}
         */
destroy:function(){b.destroy.call(this),this.$pages.css({margin:"",left:""}).removeClass(M)},/**
         * Calculate the numeric value for zoom 'auto' for this layout mode
         * @returns {float} The zoom value
         */
calculateZoomAutoValue:function(){var a=this.calculateZoomValue(Q),b=this.calculateZoomValue(R);return Math.min(a,b)},/**
         * Calculate which page is currently the "focused" page.
         * In presentation mode, it's just the state's current page.
         * @returns {int} The current page
         */
calculateCurrentPage:function(){return this.state.currentPage},/**
         * Calculates the next page
         * @returns {int} The next page number
         */
calculateNextPage:function(){return this.state.currentPage+1},/**
         * Calculates the previous page
         * @returns {int} The previous page number
         */
calculatePreviousPage:function(){return this.state.currentPage-1},/**
         * Calculates the current range of pages that are visible
         * @returns {Object} Range object with min and max values
         */
calculateVisibleRange:function(){var a=this.state.currentPage-1;return c.constrainRange(a,a,this.numPages)},/**
         * Calculates the current range of pages that are fully visible
         * @NOTE: this can be incorrect for presentations that are zoomed in
         * past the size of the viewport... I'll fix it if it becomes an issue
         * @returns {Object} Range object with min and max values
         */
calculateFullyVisibleRange:function(){return this.calculateVisibleRange()},/**
         * Set the current page and updatePageClasses
         * @param {int} page The page number
         */
setCurrentPage:function(a){var d,e,f=c.clamp(a-1,0,this.numPages);b.setCurrentPage.call(this,a),
// update CSS classes
this.$doc.find("."+u).removeClass(u),d=this.$doc.find("."+t),e=this.$pages.eq(f),d[0]!==e[0]&&(d.addClass(u).removeClass(t),e.addClass(t)),this.updateVisiblePages(!0),this.updatePageClasses(f)},/**
         * Scroll to the given page number
         * @param   {int} page The page number to scroll to
         * @returns {void}
         */
scrollToPage:function(a){this.setCurrentPage(a)},/**
         * Updates the layout elements (pages, doc, etc) CSS
         * appropriately for the current zoom level
         * @returns {void}
         */
updateLayout:function(){var a,b,c,d,e,f,g,h=this.state,i=h.zoomState,j=i.zoom,k=this.currentPage||1,l=h.pages[k-1],m=this.twoPageMode?h.pages[k]:l,n=h.viewportDimensions.clientWidth,o=h.viewportDimensions.clientHeight;a=m.actualWidth,b=l.actualWidth+(this.twoPageMode?a:0),c=l.actualHeight,d=Math.floor((b+l.paddingLeft+m.paddingRight)*j),e=Math.floor(l.totalActualHeight*j),f=Math.max(d,n),g=Math.max(e,o),this.$doc.css({width:f,height:g}),this.updatePageMargins(),f>n||g>o?this.$el.addClass("crocodoc-scrollable"):this.$el.removeClass("crocodoc-scrollable")},/**
         * Update page margins for the viewport size and zoom level
         * @returns {void}
         */
updatePageMargins:function(){var a,b,c,d,e,f,g,h,i,j=this.state,k=j.viewportDimensions.clientWidth,l=j.viewportDimensions.clientHeight;
// update pages so they are centered (preserving margins)
for(a=0,b=this.$pages.length;b>a;++a)d=this.$pages.eq(a),c=j.pages[a],i=this.twoPageMode?a%2===1?c.paddingRight:c.paddingLeft:c.paddingRight+c.paddingLeft,e=(c.actualWidth+i)*j.zoomState.zoom,f=(c.actualHeight+c.paddingTop+c.paddingBottom)*j.zoomState.zoom,this.twoPageMode?(g=Math.max(0,(k-2*e)/2),a%2===1&&(g+=e)):g=(k-e)/2,h=(l-f)/2,g=Math.max(g,0),h=Math.max(h,0),d.css({marginLeft:g,marginTop:h})},/**
         * Update page classes for presentation mode transitions
         * @returns {void}
         */
updatePageClasses:function(){var a=this.$pages,b=this.state.currentPage-1,c=b+1,d=b-1,e=20;
// @TODO: optimize this a bit
// add/removeClass is expensive, so try using hasClass
a.removeClass(M),this.twoPageMode?(c=b+2,d=b-2,a.slice(Math.max(d,0),b).addClass(G),a.slice(c,c+2).addClass(H)):(d>=0&&a.eq(d).addClass(G),c<this.numPages&&a.eq(c).addClass(H)),a.slice(0,b).addClass(I),a.slice(Math.max(0,b-e),b).addClass(K),a.slice(c).addClass(J),a.slice(c,Math.min(this.numPages,c+e)).addClass(L)}})}),Ca.addComponent("layout-"+aa,["layout-base"],function(a,b){var c=a.getUtility("common");return b.extend({init:function(){b.init.call(this),this.zoomLevels=this.config.zoomLevels.slice(),this.minZoom=this.zoomLevels[0],this.maxZoom=this.zoomLevels[this.zoomLevels.length-1]},setZoom:function(b){var d,e=this.state.zoomState,f=e.zoom;"string"==typeof b?(d=this.calculateNextZoomLevel(b),d||(d="auto"===b||"fitwidth"===b||"fitheight"===b?1:f)):d=parseFloat(b)||f,d=c.clamp(d,this.minZoom,this.maxZoom),this.config.$doc.css("font-size",10*d+"pt"),e.prevZoom=f,e.zoom=d,e.canZoomIn=this.calculateNextZoomLevel(Ca.ZOOM_IN)!==!1,e.canZoomOut=this.calculateNextZoomLevel(Ca.ZOOM_OUT)!==!1,a.broadcast("zoom",c.extend({isDraggable:this.isDraggable()},e))}})}),Ca.addComponent("layout-"+Y,["layout-"+X],function(a,b){
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
// there is nothing different about this layout aside from the name (and CSS class name)
// so we can just return the vertical layout
return b}),Ca.addComponent("layout-"+X,["layout-paged"],function(a,b){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c=a.getUtility("common"),d=a.getUtility("browser");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return b.extend({/**
         * Calculate the numeric value for zoom 'auto' for this layout mode
         * @returns {float} The zoom value
         */
calculateZoomAutoValue:function(){var a=this.state,b=this.calculateZoomValue(Q),c=this.calculateZoomValue(R);
// portrait
return a.widestPage.actualWidth>a.tallestPage.actualHeight?Math.min(1,b,c):d.mobile?b:Math.min(1,b)},/**
         * Calculate which page is currently the "focused" page.
         * In vertical mode, this is the page at the top (and if multiple columns, the leftmost page),
         * where at least half of the page is showing.
         * @returns {int} The current page
         */
calculateCurrentPage:function(){var a,b,d,e,f,g=this.state,h=g.pages;return a=c.bisectRight(h,g.scrollTop,"y0")-1,0>a?1:(f=g.scrollTop+h[a].height/2,b=c.bisectRight(h,f,"y0")-1,d=h[b].rowIndex,e=g.rows[d],1+e[0])},/**
         * Calculates the next page
         * @returns {int} The next page number
         */
calculateNextPage:function(){var a=this.state,b=a.pages[a.currentPage-1],c=b.rowIndex,d=a.rows[c+1];return d&&d[0]+1||a.currentPage},/**
         * Calculates the previous page
         * @returns {int} The previous page number
         */
calculatePreviousPage:function(){var a=this.state,b=a.pages[a.currentPage-1],c=b.rowIndex,d=a.rows[c-1];return d&&d[0]+1||a.currentPage},/**
         * Handle resize mesages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleResize:function(a){b.handleResize.call(this,a),this.updateCurrentPage()},/**
         * Handle scroll mesages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleScroll:function(a){b.handleScroll.call(this,a),this.updateCurrentPage()},/**
         * Updates the layout elements (pages, doc, etc) CSS
         * appropriately for the current zoom level
         * @returns {void}
         */
updateLayout:function(){
// vertical stuff
var a,b,c=this.state,d=c.zoomState.zoom;a=Math.floor(c.widestPage.totalActualWidth*d),b=a<=c.viewportDimensions.clientWidth?"auto":a,this.$doc.css({width:b})}})}),Ca.addComponent("lazy-loader",function(a){/**
     * Create and return a range object (eg., { min: x, max: y })
     * for the current pageLoadRange constrained to the number of pages
     * @param  {int} range The range from current page
     * @returns {Object}    The range object
     * @private
     */
function c(a){a=a||w;var b=A.page-1,c=b-a,d=b+a;return s.constrainRange(c,d,o-1)}/**
     * Loop through the pageLoadQueue and load pages sequentially,
     * setting a timeout to run again after PAGE_LOAD_INTERVAL ms
     * until the queue is empty
     * @returns {void}
     * @private
     */
function d(){var a;clearTimeout(r),v.length>0?(a=v.shift(),n[a]?u.loadPage(a,function(a){a===!1?d():r=setTimeout(d,na)}):d()):f()}/**
     * Start the page load loop
     * @returns {void}
     * @private
     */
function e(){clearTimeout(r),x=!1,r=setTimeout(d,na)}/**
     * Stop the page load loop
     * @returns {void}
     * @private
     */
function f(){clearTimeout(r),x=!0}/**
     * Add a page to the page load queue and start the page
     * load loop if necessary
     * @param  {int} index The index of the page to add
     * @returns {void}
     * @private
     */
function g(a){v.push(a),x&&e()}/**
     * Clear all pages from the page load queue and stop the loop
     * @returns {void}
     * @private
     */
function h(){v.length=0,f()}/**
     * Returns true if the given index is in the page load range, and false otherwise
     * @param   {int} index The page index
     * @param   {int} rangeLength The page range length
     * @returns {bool}      Whether the page index is in the page load range
     * @private
     */
function i(a,b){var d=c(b);return a>=d.min&&a<=d.max?!0:!1}/**
     * Returns true if the given page index should be loaded, and false otherwise
     * @param   {int} index The page index
     * @returns {bool}      Whether the page should be loaded
     * @private
     */
function j(a){var b=n[a];
// does the page exist?
if(b){
// within page load range?
if(i(a))return!0;
// is it visible?
if(l(a))return!0}return!1}/**
     * Returns true if the given page index should be unloaded, and false otherwise
     * @param   {int} index The page index
     * @param   {int} rangeLength The range length
     * @returns {bool}      Whether the page should be unloaded
     * @private
     */
function k(a,b){
// within page load range?
// within page load range?
// is it visible?
return i(a,b)?!1:l(a)?!1:!0}/**
     * Returns true if the given page is visible, and false otherwise
     * @param   {int} index The page index
     * @returns {bool}      Whether the page is visible
     * @private
     */
function l(a){
// is it visible?
return s.inArray(a+1,A.visiblePages)>-1}/**
     * Queues pages to load in order from indexFrom to indexTo
     * @param   {number} start The page index to start at
     * @param   {number} end   The page index to end at
     * @returns {void}
     */
function m(a,b){for(var c=s.sign(b-a);a!==b;)u.queuePageToLoad(a),a+=c;u.queuePageToLoad(a)}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var n,o,p,q,r,s=a.getUtility("common"),t=a.getUtility("browser"),u={},v=[],w=1,x=!0,y=1,z=!1,A={page:1,visiblePages:[1]};
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return s.extend(u,{messages:["beforezoom","pageavailable","pagefocus","ready","scroll","scrollend","zoom"],/**
         * Handle framework messages
         * @param {string} name The name of the message
         * @param {Object} data The related data for the message
         * @returns {void}
         */
onmessage:function(a,b){switch(a){case"beforezoom":this.handleBeforeZoom(b);break;case"pageavailable":this.handlePageAvailable(b);break;case"pagefocus":this.handlePageFocus(b);break;case"ready":this.handleReady();break;case"scroll":this.handleScroll();break;case"scrollend":this.handleScrollEnd();break;case"zoom":this.handleZoom(b)}},/**
         * Initialize the LazyLoader component
         * @param {Array} pageComponents The array of page components to lazily load
         * @returns {void}
         */
init:function(a){n=a,o=n.length,w=t.mobile||t.ielt10?pa:oa,w=Math.min(w,o)},/**
         * Destroy the LazyLoader component
         * @returns {void}
         */
destroy:function(){this.cancelAllLoading()},/**
         * Updates the current layout state and scroll direction
         * @param   {Object} state The layout state
         * @returns {void}
         */
updateLayoutState:function(a){y=s.sign(a.page-A.page),A=a},/**
         * Queue pages to load in the following order:
         * 1) current page
         * 2) visible pages
         * 3) pages within pageLoadRange of the viewport
         * @returns {void}
         * @NOTE: this function is debounced so it will not load and abort
         * several times if called a lot in a short time
         */
loadNecessaryPages:s.debounce(100,function(){
// cancel anything that happens to be loading first
this.cancelAllLoading(),
// load current page first
this.queuePageToLoad(A.page-1),
// then load pages that are visible in the viewport
this.loadVisiblePages(),
// then load pages beyond the viewport
this.loadPagesInRange(w)}),/**
         * Queue pages to load within the given range such that
         * proceeding pages are added before preceding pages
         * @param  {int} range The range to load beyond the current page
         * @returns {void}
         */
loadPagesInRange:function(a){var b=A.page-1;a>0&&(a=c(a),y>=0?(m(b+1,a.max),m(b-1,a.min)):(m(b-1,a.min),m(b+1,a.max)))},/**
         * Queue to load all pages that are visible according
         * to the current layoutState
         * @returns {void}
         */
loadVisiblePages:function(){var a,b;for(a=0,b=A.visiblePages.length;b>a;++a)this.queuePageToLoad(A.visiblePages[a]-1)},/**
         * Add the page at the given index to the page load queue
         * and call the preload function on the page
         * @param  {int} index The index of the page to load
         * @returns {void}
         */
queuePageToLoad:function(a){j(a)&&(n[a].preload(),g(a))},/**
         * Clear the page load queue
         * @returns {void}
         */
cancelAllLoading:function(){clearTimeout(q),clearTimeout(p),h()},/**
         * Call the load method on the page object at the specified index
         * @param  {int}      index    The index of the page to load
         * @param  {Function} callback Callback function to call always (regardless of page load success/fail)
         * @returns {void}
         */
loadPage:function(a,c){b.when(n[a]&&n[a].load()).always(c)},/**
         * Call the unload method on the page object at the specified index
         * @param  {int} index The page index
         * @returns {void}
         */
unloadPage:function(a){var b=n[a];b&&b.unload()},/**
         * Unload all pages that are not within the given range (nor visible)
         * @param {int} rangeLength The page range length
         * @returns {void}
         */
unloadUnnecessaryPages:function(a){var b,c;
// remove out-of-range SVG from DOM
for(b=0,c=n.length;c>b;++b)k(b,a)&&this.unloadPage(b)},/**
         * Handle ready messages
         * @returns {void}
         */
handleReady:function(){z=!0,this.loadVisiblePages(),q=setTimeout(function(){u.loadNecessaryPages()},qa)},/**
         * Handle pageavailable messages
         * @param   {Object} data The message data
         * @returns {void}
         */
handlePageAvailable:function(a){if(z){var b;if(a.all===!0&&(a.upto=o),a.page)this.queuePageToLoad(a.page-1);else if(a.upto)for(b=0;b<a.upto;++b)this.queuePageToLoad(b)}},/**
         * Handle pagefocus messages
         * @param   {Object} data The message data
         * @returns {void}
         */
handlePageFocus:function(a){
// NOTE: update layout state before `ready`
this.updateLayoutState(a),z&&(this.cancelAllLoading(),
// set a timeout to trigger loading so we dont cause unnecessary layouts while scrolling
p=setTimeout(function(){u.loadNecessaryPages()},200))},/**
         * Handle beforezoom messages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleBeforeZoom:function(a){z&&(this.cancelAllLoading(),
// @NOTE: for performance reasons, we unload as many pages as possible just before zooming
// so we don't have to layout as many pages at a time immediately after the zoom.
// This is arbitrarily set to 2x the number of visible pages before the zoom, and
// it seems to work alright.
this.unloadUnnecessaryPages(2*a.visiblePages.length))},/**
         * Handle zoom messages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleZoom:function(a){
// NOTE: update layout state before `ready`
this.updateLayoutState(a),z&&this.loadNecessaryPages()},/**
         * Handle scroll messages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleScroll:function(){this.cancelAllLoading()},/**
         * Handle scrollend messages
         * @param   {Object} data The message data
         * @returns {void}
         */
handleScrollEnd:function(){z&&(this.loadNecessaryPages(),this.unloadUnnecessaryPages(w))}})}),Ca.addComponent("page-img",function(a){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c,d,e,f,g=a.getUtility("browser"),h=!1,i=g.mobile;
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the page-img component
         * @param  {Element} el     The element to insert the image into
         * @param  {number} pageNum The page number
         * @returns {void}
         */
init:function(a,c){d=b(a),f=c},/**
         * Destroy the page-img component
         * @returns {void}
         */
destroy:function(){i=!0,this.unload(),d.empty()},/**
         * Prepare the element for loading
         * @returns {void}
         */
prepare:function(){},/**
         * Preload the image
         * @returns {void}
         */
preload:function(){e||(e=a.get("page-img",f))},/**
         * Load the image
         * @returns {$.Promise}    A jQuery Promise object
         */
load:function(){return this.preload(),e.done(function(a){h||(h=!0,c=b(a).appendTo(d))}),e.fail(function(b){h=!1,b&&a.broadcast("asseterror",b)}),e},/**
         * Unload the img if necessary
         * @returns {void}
         */
unload:function(){e&&(e.abort(),e=null),i&&(c&&(c.remove(),c=null),h=!1)}}}),Ca.addComponent("page-links",function(a){/**
     * Create a link element given link data
     * @param   {Object} link The link data
     * @returns {void}
     * @private
     */
function c(a){var c=b("<a>").addClass(A),g=a.bbox[0],h=a.bbox[1],i={};if(f.ie&&
// @NOTE: IE doesn't allow override of ctrl+click on anchor tags,
// but there is a workaround to add a child element (which triggers
// the onclick event first)
b("<span>").appendTo(c).on("click",d),c.css({left:g+"pt",top:h+"pt",width:a.bbox[2]-g+"pt",height:a.bbox[3]-h+"pt"}),a.uri){if(!/^http|^mailto/.test(a.uri))
// don't embed this link... we don't trust the protocol
return;i.href=encodeURI(a.uri),i.target="_blank"}else a.destination&&(i.href="#page-"+a.destination.pagenum);c.attr(i),c.data("link",a),c.appendTo(e)}/**
     * Handle link clicks
     * @param   {Event} event The event object
     * @returns {void}
     * @private
     */
function d(c){var d=f.ie?c.target.parentNode:c.target,e=b(d),g=e.data("link");g&&a.broadcast("linkclick",g),c.preventDefault()}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var e,f=a.getUtility("browser");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the page-links component
         * @param  {Array} links Links configuration array
         * @returns {void}
         * @TODO (possible): make a links data-provider instead of passing
         * them in as an argument?
         */
init:function(a,c){e=b(a),this.createLinks(c),f.ie||e.on("click","."+A,d)},/**
         * Destroy the page-links component
         * @returns {void}
         */
destroy:function(){
// @NOTE: individual click event handlers needed for IE are
// implicitly removed by jQuery when we empty the links container
e.empty().off("click"),e=f=null},/**
         * Create and insert link elements into the element
         * @param   {Array} links Array of link data
         * @returns {void}
         */
createLinks:function(a){var b,d;for(b=0,d=a.length;d>b;++b)c(a[b])}}}),Ca.addComponent("page-svg",function(c){/**
     * Create and return a jQuery object for the SVG element
     * @returns {Object} The SVG $element
     * @private
     */
function d(){switch(v){case ua:case Aa:return b("<iframe>");case za:case va:return b("<object>").attr({type:ra,data:"data:"+ra+";base64,"+a.btoa(ta)});case wa:return b("<div>");case xa:return b("<object>");case ya:case Ba:return b("<img>")}}/**
     * Create the svg element if it hasn't been created,
     * insert the SVG into the DOM if necessary
     * @returns {void}
     * @private
     */
function e(){k&&0!==k.length||(s=!1,k=d()),0===k.parent().length&&k.appendTo(l)}/**
     * Load svg text if necessary
     * @returns {$.Promise}
     * @private
     */
function f(){
// @NOTE: these embed strategies don't require svg text to be loaded
return s||v===xa||v===ya?b.Deferred().resolve().promise({abort:function(){}}):c.get("page-svg",n)}/**
     * Fixes a bug in Safari where <use> elements are not supported properly
     * by replacing each <use> element with a clone of its referenced <image>
     * @param   {Document} contentDocument The SVG document
     * @returns {void}
     */
function g(a){
// find all <use> elements
var b=a.querySelectorAll("use");[].forEach.call(b,function(b){var c=b.getAttribute("xlink:href"),
// clone the referenced <image> element
d=a.querySelector(c).cloneNode(),e=b.parentNode;
// remove the id so we don't have duplicates
d.removeAttribute("id"),
// copy over the transform
d.setAttribute("transform",b.getAttribute("transform")),
// replace the use with the image
e.replaceChild(d,b)})}/**
     * Embed the SVG into the page
     * @returns {void}
     * @private
     */
function h(b){var d,e,f,h,i,j=k[0].contentDocument,l=k[0].contentWindow||
// @NOTE: supports older versions of ff
j&&j.defaultView;switch(v){case ua:
// @NOTE: IE 9 fix. This line in the file is causing the page not to render in IE 9.
// The link is not needed here anymore because we are including the stylesheet separately.
o.ielt10&&(b=b.replace(/<xhtml:link.*/,"")),h=sa+b,
// @NOTE: documentElement.innerHTML is read-only in IE
o.ielt10?j.body.innerHTML=h:(j.documentElement.innerHTML=h,
// @NOTE: there is a bug in Safari 6 where <use>
// elements don't work properly
(o.ios||o.safari)&&o.version<7&&g(j)),f=j.getElementsByTagName("svg")[0];break;case Aa:j.documentElement.innerHTML=sa;var m=j.getElementsByTagName("head")[0]||j.documentElement,q=j.createElement("script"),r="("+proxySVG+")()";// IIFE to create window.loadSVG
q.type="text/javascript";try{
// doesn't work on ie...
q.appendChild(document.createTextNode(r))}catch(s){
// IE has funky script nodes
q.text=r}
// NOTE: return is necessary here because we are waiting for a callback
// before unsetting svgText
return m.insertBefore(q,m.firstChild),void("complete"===j.readyState?l.loadSVG(b):l.onload=function(){this.loadSVG(b)});case va:d=new p,e=d.parseFromString(b,ra),f=j.importNode(e.documentElement,!0),j.documentElement.appendChild(f);break;case za:l.loadSVG(b),f=j.querySelector("svg");break;case wa:d=new p,e=d.parseFromString(b,ra),f=document.importNode(e.documentElement,!0),k.append(f);break;case xa:k.attr({type:ra,data:c.getDataProvider("page-svg").getURL(n)}),f=k[0];break;case ya:f=k[0],f.src=c.getDataProvider("page-svg").getURL(n);break;case Ba:f=k[0],i="data:"+ra,!o.ie&&a.btoa?f.src=i+";base64,"+a.btoa(b):f.src=i+","+encodeURIComponent(b)}
// make sure the svg width/height are explicity set to 100%
f.setAttribute("width","100%"),f.setAttribute("height","100%")}/**
     * handle SVG load success
     * @param   {string} text The SVG text
     * @returns {void}
     */
function i(a){q||r||(!s&&a&&(h(a),s=!0,u||(m.abort(),m=null)),
// always insert the svg el when load was successful
0===k.parent().length&&k.appendTo(l))}/**
     * Handle SVG load failure
     * @param   {*} error The error
     * @returns {void}
     */
function j(a){c.broadcast("asseterror",a),s=!1,m&&m.abort()}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var k,l,m,n,o=c.getUtility("browser"),p=a.DOMParser,q=!1,r=!1,s=!1,t=c.getConfig(),u=o.mobile||o.ielt10,
// * IE 9-10 and firefox perform better with <img> elements
// * IE 11 crashes when using img elements for some reason
// * Everything else is happy with iframe + innerhtml
v=o.ielt11||o.firefox?Ba:ua;
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the page-svg component
         * @param {jQuery} $el The element to load SVG layer into
         * @param  {number} pageNum The page number
         * @returns {void}
         */
init:function(a,b){l=a,n=b,v=t.embedStrategy||v},/**
         * Destroy the page-svg component
         * @returns {void}
         */
destroy:function(){q=!0,u=!0,this.unload(),l.empty()},/**
         * Prepare the element for loading
         * @returns {void}
         */
prepare:function(){e()},/**
         * Prepare the SVG object to be loaded and start loading SVG text
         * @returns {void}
         */
preload:function(){this.prepare(),m||(m=f())},/**
         * Load the SVG and call callback when complete.
         * If there was an error, callback's first argument will be
         * an error message, and falsy otherwise.
         * @returns {$.Promise}    A jQuery promise object
         */
load:function(){return r=!1,this.preload(),m.done(i).fail(j),m},/**
         * Unload the SVG object if necessary
         * @returns {void}
         */
unload:function(){r=!0,m&&"resolved"!==m.state()&&(m.abort(),m=null),u&&(k&&(k.remove(),k=null),s=!1)}}}),Ca.addComponent("page-text",function(a){/**
     * Return true if we should use the text layer, false otherwise
     * @returns {bool}
     * @private
     */
function c(){return n.enableTextSelection&&!j.ielt9}/**
     * Handle success loading HTML text
     * @param {string} text The HTML text
     * @returns {void}
     * @private
     */
function d(a){var b,c;!a||m||l||(m=!0,b=document.implementation.createHTMLDocument(""),b.getElementsByTagName("body")[0].innerHTML=a,a=null,c=document.importNode(b.querySelector("."+z),!0),g.attr("class",c.getAttribute("class")),g.html(c.innerHTML),k.fix(g))}function e(b){b&&a.broadcast("asseterror",b)}/**
     * Load text html if necessary and insert it into the element
     * @returns {$.Promise}
     * @private
     */
function f(){
// already load(ed|ing)?
return h||(h=c()?a.get("page-text",i):b.Deferred().resolve().promise({abort:function(){}})),h}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var g,h,i,j=a.getUtility("browser"),k=a.getUtility("subpx"),l=!1,m=!1,n=a.getConfig();
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{/**
         * Initialize the page-text component
         * @param {jQuery} $el The jQuery element to load the text layer into
         * @returns {void}
         */
init:function(a,b){g=a,i=b},/**
         * Destroy the page-text component
         * @returns {void}
         */
destroy:function(){l=!0,this.unload(),g.empty()},/**
         * Start loading HTML text
         * @returns {void}
         */
preload:function(){f()},/**
         * Load the html text for the text layer and insert it into the element
         * if text layer is enabled and is not loading/has not already been loaded
         * @returns {$.Promise} A promise to load the text layer
         */
load:function(){return f().done(d).fail(e)},/**
         * Stop loading the text layer (no need to actually remove it)
         * @returns {void}
         */
unload:function(){h&&"resolved"!==h.state()&&(h.abort(),h=null)},/**
         * Enable text selection
         * @returns {void}
         */
enable:function(){g.css("display",""),
// we created an empty promise if text selection was previously disabled,
// so we can scrap it so a new promise will be created next time this
// page is requested
h&&!m&&(h=null)},/**
         * Disable text selection
         * @returns {void}
         */
disable:function(){g.css("display","none")}}}),Ca.addComponent("page",function(a){
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var c,d,e,f,g,h,i,j,k=a.getUtility("support"),l=a.getUtility("common"),m=!1;return{messages:["pageavailable","pagefocus","textenabledchange","zoom"],/**
         * Handle framework messages
         * @param {string} name The name of the message
         * @param {Object} data The related data for the message
         * @returns {void}
         */
onmessage:function(a,b){switch(a){case"pageavailable":(b.page===h+1||b.upto>h||b.all===!0)&&j===ba&&(j=ca);break;case"textenabledchange":b.enabled===!0?this.enableTextSelection():this.disableTextSelection();break;case"pagefocus":
// falls through
case"zoom":i=g===b.page||l.inArray(g,b.visiblePages)>-1}},/**
         * Initialize the Page component
         * @returns {void}
         */
init:function(b,i){var l,m,n;c=b,m=b.find("."+y),l=b.find("."+z),n=b.find("."+B),j=i.status||ca,h=i.index,g=h+1,this.config=i,i.url=i.url||"",d=a.createComponent("page-text"),void 0===i.useSVG&&(i.useSVG=!0),e=k.svg&&i.useSVG?a.createComponent("page-svg"):a.createComponent("page-img"),d.init(l,g),e.init(m,g),i.enableLinks&&i.links.length&&(f=a.createComponent("page-links"),f.init(n,i.links))},/**
         * Destroy the page component
         * @returns {void}
         */
destroy:function(){this.unload()},/**
         * Preload the SVG if the page is not loaded
         * @returns {void}
         */
preload:function(){e.prepare(),j===ca&&(e.preload(),d.preload())},/**
         * Load and show SVG and text assets for this page
         * @returns {$.Promise}    jQuery Promise object or false if the page is not loading
         */
load:function(){var f=this;
// the page has failed to load for good... don't try anymore
// the page has failed to load for good... don't try anymore
// don't actually load if the page is converting
// request assets to be loaded... but only ACTUALLY load if it is
// not loaded already
return m=!0,j===fa?!1:j===ba?!1:(j!==ea&&(j=da),b.when(e.load(),d.load()).done(function(){m?j!==ea&&(c.removeClass(D),j=ea,a.broadcast("pageload",{page:g})):f.unload()}).fail(function(b){j=fa,c.addClass(E),a.broadcast("pagefail",{page:h+1,error:b})}))},/**
         * Unload/hide SVG and text assets for this page
         * @returns {void}
         */
unload:function(){m=!1,e.unload(),d.unload(),j===ea&&(j=ca,c.addClass(D),c.removeClass(E),a.broadcast("pageunload",{page:g}))},/**
         * Enable text selection, loading text assets if the page is visible
         * @returns {void}
         */
enableTextSelection:function(){d.enable(),i&&d.load()},/**
         * Disable text selection
         * @returns {void}
         */
disableTextSelection:function(){d.disable()}}}),Ca.addComponent("resizer",function(c){/**
     * Fire the resize event with the proper data
     * @returns {void}
     * @private
     */
function d(){c.broadcast("resize",{
// shortcuts for offsetWidth/height
width:k,height:l,
// client width is width of the inner, visible area
clientWidth:i,clientHeight:j,
// offset width is the width of the element, including border,
// padding, and scrollbars
offsetWidth:k,offsetHeight:l})}/**
     * Apply `position: relative` style to the element if necessary
     * @returns {void}
     * @private
     */
function e(){var a=m.getComputedStyle(h);
// if the element is not positioned, add position relative so the
// iframe can be positioned properly
a&&"static"===a.position&&b(h).css({position:"relative"})}/**
     * Initialize an iframe to fire events on resize
     * @returns {void}
     * @private
     */
function f(){var a=b('<iframe frameborder="0">'),c=b("<div>");a.add(c).css({opacity:0,visiblility:"hidden",position:"absolute",width:"100%",height:"100%",top:0,left:0,border:0}),a.prependTo(c.prependTo(h)),e(),o=b(a[0].contentWindow),o.on("resize",g)}/**
     * Check if the element has resized, and broadcast the resize event if so
     * @returns {void}
     * @private
     */
function g(){var b=h.offsetHeight,f=h.offsetWidth;
// check if we're in a frame
// check if we're in a frame
// fix the element position again if necessary
//on touch devices, the offset height is sometimes zero as content is loaded
return r&&0===q&&0!==a.innerWidth?(q=a.innerWidth,e(),void c.broadcast("layoutchange")):void(b&&(b!==l||f!==k)&&(l=b,k=f,j=h.clientHeight,i=h.clientWidth,d()))}var h,i,j,k,l,m=c.getUtility("common"),n=[""," webkit"," moz"," "].join("fullscreenchange")+
// @NOTE: IE 11 uses upper-camel-case for this, which is apparently necessary
"MSFullscreenChange",o=b(a),p=b(document),q=0,r=function(){try{return a.self!==a.top}catch(b){return!0}}();return{messages:["layoutchange"],/**
         * Handle framework messages
         * @returns {void}
         */
onmessage:function(){l=null,g()},/**
         * Initialize the Resizer component with an element to watch
         * @param  {HTMLElement} el The element to watch
         * @returns {void}
         */
init:function(c){h=b(c).get(0),h===a?(h=document.documentElement,o.on("resize",g)):f(),p.on(n,g),g()},/**
         * Destroy the Resizer component
         * @returns {void}
         */
destroy:function(){p.off(n,g),o.off("resize",g)}}}),Ca.addComponent("scroller",function(a){/**
     * Build event data object for firing scroll events
     * @returns {Object} Scroll event data object
     * @private
     */
function c(){return{scrollTop:j.scrollTop(),scrollLeft:j.scrollLeft()}}/**
     * Handle scrollend
     * @returns {void}
     * @private
     */
function d(){r=!1,w=null,clearTimeout(k),a.broadcast("scrollend",c())}/**
     * Handle scroll events
     * @returns {void}
     * @private
     */
function e(){
// if we are just starting scrolling, fire scrollstart event
r||(r=!0,a.broadcast("scrollstart",c())),clearTimeout(k),k=setTimeout(d,q),x()}/**
     * Handle touch start events
     * @returns {void}
     * @private
     */
function f(){s=!0,t=!1,u=!1,e()}/**
     * Handle touchmove events
     * @returns {void}
     * @private
     */
function g(){u=!0,e()}/**
     * Handle touchend events
     * @returns {void}
     * @private
     */
function h(){s=!1,t=!0,v=(new Date).getTime(),u&&i()}/**
     * Fire fake scroll events.
     * iOS doesn't fire events during the 'momentum' part of scrolling
     * so this is used to fake these events until the page stops moving.
     * @returns {void}
     * @private
     */
function i(){return clearTimeout(k),null===w&&(w=(new Date).getTime()),(new Date).getTime()-w>n?void d():(x(),void(k=setTimeout(i,o)))}var j,k,l=a.getUtility("common"),m=a.getUtility("browser"),n=3e3,o=30,p=200,q=m.mobile?500:250,r=!1,s=!1,t=!1,u=!1,v=0,w=null,x=l.throttle(p,function(){a.broadcast("scroll",c())});return{/**
         * Initialize the scroller component
         * @param   {Element} el The Element
         * @returns {void}
         */
init:function(a){j=b(a),j.on("scroll",e),j.on("touchstart",f),j.on("touchmove",g),j.on("touchend",h)},/**
         * Destroy the scroller component
         * @returns {void}
         */
destroy:function(){clearTimeout(k),j.off("scroll",e),j.off("touchstart",f),j.off("touchmove",g),j.off("touchend",h)}}}),Ca.addComponent("viewer-base",function(c){/**
     * Add CSS classes to the element for necessary feature/support flags
     * @returns {void}
     * @private
     */
function d(){
// add SVG version number flag
w.attr(e,v.metadata.version||"0.0.0"),
//add CSS flags
E.mobile&&w.addClass(o),E.ielt9&&w.addClass(p),F.svg&&v.useSVG&&w.addClass(q)}/**
     * Create and insert basic viewer DOM structure
     * @returns {void}
     * @private
     */
function i(){
// create viewer HTML
w.html(Ca.viewerTemplate),v.useWindowAsViewport?(v.$viewport=b(a),w.addClass(r)):v.$viewport=w.find("."+h),v.$doc=w.find("."+g)}/**
     * Initialize all plugins specified for this viewer instance
     * @returns {void}
     * @private
     */
function l(){var a,b,d=v.plugins||{};for(a in d)b=c.createComponent("plugin-"+a),b&&D.isFn(b.init)&&b.init(v.plugins[a])}/**
     * Complete intialization after document metadata has been loaded;
     * ie., bind events, init lazyloader and layout, broadcast ready message
     * @returns {void}
     * @private
     */
function m(){d(),z=c.createComponent("scroller"),z.init(v.$viewport),A=c.createComponent("resizer"),A.init(v.$viewport);var a;switch(v.metadata.type){case"text":
// load text-based viewer
a=c.createComponent("controller-text"),
// force the text layout only
// @TODO: allow overriding the layout eventually
v.layout=aa;break;case"paged":/* falls through */
default:a=c.createComponent("controller-paged")}a.init(),
// disable text selection if necessary
"text"===v.metadata.type?v.enableTextSelection||u.disableTextSelection():E.ielt9&&u.disableTextSelection(),
// disable links if necessary
// @NOTE: links are disabled in IE < 9
(!v.enableLinks||E.ielt9)&&u.disableLinks(),
// set the initial layout
u.setLayout(v.layout),
// broadcast ready message
c.broadcast("ready",{page:v.page||1,numPages:v.numPages}),c.ready()}/**
     * Handler for linkclick messages
     * @returns {void}
     * @private
     */
function n(b){var c=u.fire("linkclick",b);c.isDefaultPrevented()||(b.uri?a.open(b.uri):b.destination&&u.scrollTo(b.destination.pagenum))}/**
     * Enable or disable the dragger given the `isDraggable` flag
     * @param   {Boolean} isDraggable Whether or not the layout is draggable
     * @returns {void}
     * @private
     */
function s(a){a?B||(w.addClass(j),B=c.createComponent("dragger"),B.init(v.$viewport)):B&&(w.removeClass(j),c.destroyComponent(B),B=null)}/**
     * Validates and normalizes queryParams config option
     * @returns {void}
     */
function t(){var a;v.queryParams&&(a="string"==typeof v.queryParams?v.queryParams.replace(/^\?/,""):D.param(v.queryParams)),v.queryString=a?"?"+a:""}
//--------------------------------------------------------------------------
// Private
//--------------------------------------------------------------------------
var u,// the viewer API object
v,w,x,y,z,A,B,C,D=c.getUtility("common"),E=c.getUtility("browser"),F=c.getUtility("support");
//--------------------------------------------------------------------------
// Public
//--------------------------------------------------------------------------
return{messages:["asseterror","destroy","dragend","dragstart","fail","layoutchange","linkclick","pagefail","pagefocus","pageload","pageunload","ready","resize","scrollstart","scrollend","zoom"],/**
         * Handle framework messages
         * @param {string} name The name of the message
         * @param {any} data The related data for the message
         * @returns {void}
         */
onmessage:function(a,b){switch(a){case"layoutchange":u.updateLayout();break;case"linkclick":n(b);break;case"zoom":
// artificially adjust the reported zoom to be accuate given the page scale
b.zoom*=v.pageScale,b.prevZoom*=v.pageScale,v.enableDragging&&s(b.isDraggable),
// forward zoom event to external event handlers
u.fire(a,b);break;case"dragstart":w.hasClass(k)||w.addClass(k),
// forward zoom event to external event handlers
u.fire(a,b);break;case"dragend":w.hasClass(k)&&w.removeClass(k),
// forward zoom event to external event handlers
u.fire(a,b);break;default:
// forward subscribed framework messages to external event handlers
u.fire(a,b)}},/**
         * Initialize the viewer api
         * @returns {void}
         */
init:function(){
// add a / to the end of the base url if necessary
if(v=c.getConfig(),u=v.api,v.namespace=f+"-"+v.id,w=v.$el,w.addClass(f),w.addClass(v.namespace),!v.url)throw new Error("no URL given for viewer assets");/\/$/.test(v.url)||(v.url+="/"),
// make the url absolute
v.url=c.getUtility("url").makeAbsolute(v.url),void 0===v.useSVG&&(v.useSVG=!0),t(),i(),l()},/**
         * Destroy the viewer-base component
         * @returns {void}
         */
destroy:function(){
// empty container and remove all class names that contain "crocodoc"
w.empty().removeClass(function(a,b){var c=b.match(new RegExp("crocodoc\\S+","g"));return c&&c.join(" ")}),
// remove the stylesheet
b(x).remove(),C&&C.abort()},/**
         * Set the layout to the given mode, destroying and cleaning up the current
         * layout if there is one
         * @param  {string} layoutMode The layout mode
         * @returns {Layout} The layout object
         */
setLayout:function(a){
// create a layout component with the new layout config
var b,d=v.page,e=v.zoom||1,f=v.layout;
// if there is already a layout, save some state
if(y){
// ignore this if we already have the specified layout
if(a===f)return y;d=y.state.currentPage,e=y.state.zoomState}if(b=c.createComponent("layout-"+a),!b)throw new Error("Invalid layout "+a);
// remove and destroy the existing layout component
// @NOTE: this must be done after we decide if the
// new layout exists!
return y&&c.destroyComponent(y),v.layout=a,y=b,y.init(),y.setZoom(e.zoomMode||e.zoom||e),D.isFn(y.scrollTo)&&y.scrollTo(d),v.currentLayout=y,c.broadcast("layoutchange",{previousLayout:f,layout:a}),y},/**
         * Load the metadata and css for this document
         * @returns {void}
         */
loadAssets:function(){var a,d,e,f;C||(d=c.get("metadata"),d.then(function(a){v.metadata=a}),E.ielt9?(x=D.insertCSS(""),v.stylesheet=x.styleSheet,a=b.when("").promise({abort:function(){}})):(a=c.get("stylesheet"),a.then(function(a){x=D.insertCSS(a),v.stylesheet=x.sheet})),!v.autoloadFirstPage||v.pageStart&&1!==v.pageStart||(F.svg&&v.useSVG?e=c.get("page-svg",1):v.conversionIsComplete&&(e=c.get("page-img",1)),v.enableTextSelection&&(f=c.get("page-text",1))),C=b.when(d,a).fail(function(a){C&&C.abort(),c.ready(),c.broadcast("asseterror",a),c.broadcast("fail",a)}).then(m).promise({abort:function(){C=null,d.abort(),a.abort(),e&&e.abort(),f&&f.abort()}}))}}}),Ca})}("undefined"!=typeof window?window:this);